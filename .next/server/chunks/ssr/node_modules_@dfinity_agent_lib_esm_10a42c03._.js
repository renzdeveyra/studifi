module.exports = {

"[project]/node_modules/@dfinity/agent/lib/esm/agent/api.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Codes used by the replica for rejecting a message.
 * See {@link https://sdk.dfinity.org/docs/interface-spec/#reject-codes | the interface spec}.
 */ __turbopack_context__.s({
    "ReplicaRejectCode": (()=>ReplicaRejectCode)
});
var ReplicaRejectCode;
(function(ReplicaRejectCode) {
    ReplicaRejectCode[ReplicaRejectCode["SysFatal"] = 1] = "SysFatal";
    ReplicaRejectCode[ReplicaRejectCode["SysTransient"] = 2] = "SysTransient";
    ReplicaRejectCode[ReplicaRejectCode["DestinationInvalid"] = 3] = "DestinationInvalid";
    ReplicaRejectCode[ReplicaRejectCode["CanisterReject"] = 4] = "CanisterReject";
    ReplicaRejectCode[ReplicaRejectCode["CanisterError"] = 5] = "CanisterError";
})(ReplicaRejectCode || (ReplicaRejectCode = {})); //# sourceMappingURL=api.js.map
}}),
"[project]/node_modules/@dfinity/agent/lib/esm/utils/buffer.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Concatenate multiple array buffers.
 * @param buffers The buffers to concatenate.
 */ __turbopack_context__.s({
    "bufEquals": (()=>bufEquals),
    "bufFromBufLike": (()=>bufFromBufLike),
    "compare": (()=>compare),
    "concat": (()=>concat),
    "fromHex": (()=>fromHex),
    "toHex": (()=>toHex),
    "uint8ToBuf": (()=>uint8ToBuf)
});
function concat(...buffers) {
    const result = new Uint8Array(buffers.reduce((acc, curr)=>acc + curr.byteLength, 0));
    let index = 0;
    for (const b of buffers){
        result.set(new Uint8Array(b), index);
        index += b.byteLength;
    }
    return result.buffer;
}
function toHex(buffer) {
    return [
        ...new Uint8Array(buffer)
    ].map((x)=>x.toString(16).padStart(2, '0')).join('');
}
const hexRe = new RegExp(/^[0-9a-fA-F]+$/);
function fromHex(hex) {
    if (!hexRe.test(hex)) {
        throw new Error('Invalid hexadecimal string.');
    }
    const buffer = [
        ...hex
    ].reduce((acc, curr, i)=>{
        acc[i / 2 | 0] = (acc[i / 2 | 0] || '') + curr;
        return acc;
    }, []).map((x)=>Number.parseInt(x, 16));
    return new Uint8Array(buffer).buffer;
}
function compare(b1, b2) {
    if (b1.byteLength !== b2.byteLength) {
        return b1.byteLength - b2.byteLength;
    }
    const u1 = new Uint8Array(b1);
    const u2 = new Uint8Array(b2);
    for(let i = 0; i < u1.length; i++){
        if (u1[i] !== u2[i]) {
            return u1[i] - u2[i];
        }
    }
    return 0;
}
function bufEquals(b1, b2) {
    return compare(b1, b2) === 0;
}
function uint8ToBuf(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength).buffer;
}
function bufFromBufLike(bufLike) {
    if (bufLike instanceof Uint8Array) {
        return uint8ToBuf(bufLike);
    }
    if (bufLike instanceof ArrayBuffer) {
        return bufLike;
    }
    if (Array.isArray(bufLike)) {
        return uint8ToBuf(new Uint8Array(bufLike));
    }
    if ('buffer' in bufLike) {
        return bufFromBufLike(bufLike.buffer);
    }
    return uint8ToBuf(new Uint8Array(bufLike));
} //# sourceMappingURL=buffer.js.map
}}),
"[project]/node_modules/@dfinity/agent/lib/esm/errors.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "ActorCallError": (()=>ActorCallError),
    "AgentError": (()=>AgentError),
    "QueryCallRejectedError": (()=>QueryCallRejectedError),
    "UpdateCallRejectedError": (()=>UpdateCallRejectedError)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/principal/lib/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$api$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/agent/api.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/utils/buffer.js [app-ssr] (ecmascript)");
;
;
;
class AgentError extends Error {
    constructor(message){
        super(message);
        this.message = message;
        this.name = 'AgentError';
        this.__proto__ = AgentError.prototype;
        Object.setPrototypeOf(this, AgentError.prototype);
    }
}
class ActorCallError extends AgentError {
    constructor(canisterId, methodName, type, props){
        const cid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Principal"].from(canisterId);
        super([
            `Call failed:`,
            `  Canister: ${cid.toText()}`,
            `  Method: ${methodName} (${type})`,
            ...Object.getOwnPropertyNames(props).map((n)=>`  "${n}": ${JSON.stringify(props[n])}`)
        ].join('\n'));
        this.canisterId = canisterId;
        this.methodName = methodName;
        this.type = type;
        this.props = props;
        this.name = 'ActorCallError';
        this.__proto__ = ActorCallError.prototype;
        Object.setPrototypeOf(this, ActorCallError.prototype);
    }
}
class QueryCallRejectedError extends ActorCallError {
    constructor(canisterId, methodName, result){
        var _a;
        const cid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Principal"].from(canisterId);
        super(cid, methodName, 'query', {
            Status: result.status,
            Code: (_a = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$api$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ReplicaRejectCode"][result.reject_code]) !== null && _a !== void 0 ? _a : `Unknown Code "${result.reject_code}"`,
            Message: result.reject_message
        });
        this.result = result;
        this.name = 'QueryCallRejectedError';
        this.__proto__ = QueryCallRejectedError.prototype;
        Object.setPrototypeOf(this, QueryCallRejectedError.prototype);
    }
}
class UpdateCallRejectedError extends ActorCallError {
    constructor(canisterId, methodName, requestId, response){
        const cid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Principal"].from(canisterId);
        super(cid, methodName, 'update', Object.assign({
            'Request ID': (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toHex"])(requestId)
        }, response.body ? Object.assign(Object.assign({}, response.body.error_code ? {
            'Error code': response.body.error_code
        } : {}), {
            'Reject code': String(response.body.reject_code),
            'Reject message': response.body.reject_message
        }) : {
            'HTTP status code': response.status.toString(),
            'HTTP status text': response.statusText
        }));
        this.requestId = requestId;
        this.response = response;
        this.name = 'UpdateCallRejectedError';
        this.__proto__ = UpdateCallRejectedError.prototype;
        Object.setPrototypeOf(this, UpdateCallRejectedError.prototype);
    }
} //# sourceMappingURL=errors.js.map
}}),
"[project]/node_modules/@dfinity/agent/lib/esm/request_id.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "hash": (()=>hash),
    "hashOfMap": (()=>hashOfMap),
    "hashValue": (()=>hashValue),
    "requestIdOf": (()=>requestIdOf)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$candid$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/candid/lib/esm/index.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$candid$2f$lib$2f$esm$2f$utils$2f$leb128$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/candid/lib/esm/utils/leb128.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$borc$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/borc/src/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha256$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/sha256.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/utils/buffer.js [app-ssr] (ecmascript)");
;
;
;
;
function hash(data) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["uint8ToBuf"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha256$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["sha256"].create().update(new Uint8Array(data)).digest());
}
function hashValue(value) {
    if (value instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$borc$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].Tagged) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return hashValue(value.value);
    } else if (typeof value === 'string') {
        return hashString(value);
    } else if (typeof value === 'number') {
        return hash((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$candid$2f$lib$2f$esm$2f$utils$2f$leb128$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lebEncode"])(value));
    } else if (value instanceof ArrayBuffer || ArrayBuffer.isView(value)) {
        return hash(value);
    } else if (Array.isArray(value)) {
        const vals = value.map(hashValue);
        return hash((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["concat"])(...vals));
    } else if (value && typeof value === 'object' && value._isPrincipal) {
        return hash(value.toUint8Array());
    } else if (typeof value === 'object' && value !== null && typeof value.toHash === 'function') {
        return hashValue(value.toHash());
    // TODO This should be move to a specific async method as the webauthn flow required
    // the flow to be synchronous to ensure Safari touch id works.
    // } else if (value instanceof Promise) {
    //   return value.then(x => hashValue(x));
    } else if (typeof value === 'object') {
        return hashOfMap(value);
    } else if (typeof value === 'bigint') {
        // Do this check much later than the other bigint check because this one is much less
        // type-safe.
        // So we want to try all the high-assurance type guards before this 'probable' one.
        return hash((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$candid$2f$lib$2f$esm$2f$utils$2f$leb128$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lebEncode"])(value));
    }
    throw Object.assign(new Error(`Attempt to hash a value of unsupported type: ${value}`), {
        // include so logs/callers can understand the confusing value.
        // (when stringified in error message, prototype info is lost)
        value
    });
}
const hashString = (value)=>{
    const encoded = new TextEncoder().encode(value);
    return hash(encoded);
};
function requestIdOf(request) {
    return hashOfMap(request);
}
function hashOfMap(map) {
    const hashed = Object.entries(map).filter(([, value])=>value !== undefined).map(([key, value])=>{
        const hashedKey = hashString(key);
        const hashedValue = hashValue(value);
        return [
            hashedKey,
            hashedValue
        ];
    });
    const traversed = hashed;
    const sorted = traversed.sort(([k1], [k2])=>{
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["compare"])(k1, k2);
    });
    const concatenated = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["concat"])(...sorted.map((x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["concat"])(...x)));
    const result = hash(concatenated);
    return result;
} //# sourceMappingURL=request_id.js.map
}}),
"[project]/node_modules/@dfinity/agent/lib/esm/auth.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "AnonymousIdentity": (()=>AnonymousIdentity),
    "SignIdentity": (()=>SignIdentity),
    "createIdentityDescriptor": (()=>createIdentityDescriptor)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/principal/lib/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$request_id$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/request_id.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/utils/buffer.js [app-ssr] (ecmascript)");
var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
;
;
;
const domainSeparator = new TextEncoder().encode('\x0Aic-request');
class SignIdentity {
    /**
     * Get the principal represented by this identity. Normally should be a
     * `Principal.selfAuthenticating()`.
     */ getPrincipal() {
        if (!this._principal) {
            this._principal = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Principal"].selfAuthenticating(new Uint8Array(this.getPublicKey().toDer()));
        }
        return this._principal;
    }
    /**
     * Transform a request into a signed version of the request. This is done last
     * after the transforms on the body of a request. The returned object can be
     * anything, but must be serializable to CBOR.
     * @param request - internet computer request to transform
     */ async transformRequest(request) {
        const { body } = request, fields = __rest(request, [
            "body"
        ]);
        const requestId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$request_id$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["requestIdOf"])(body);
        return Object.assign(Object.assign({}, fields), {
            body: {
                content: body,
                sender_pubkey: this.getPublicKey().toDer(),
                sender_sig: await this.sign((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["concat"])(domainSeparator, requestId))
            }
        });
    }
}
class AnonymousIdentity {
    getPrincipal() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Principal"].anonymous();
    }
    async transformRequest(request) {
        return Object.assign(Object.assign({}, request), {
            body: {
                content: request.body
            }
        });
    }
}
function createIdentityDescriptor(identity) {
    const identityIndicator = 'getPublicKey' in identity ? {
        type: 'PublicKeyIdentity',
        publicKey: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toHex"])(identity.getPublicKey().toDer())
    } : {
        type: 'AnonymousIdentity'
    };
    return identityIndicator;
} //# sourceMappingURL=auth.js.map
}}),
"[project]/node_modules/@dfinity/agent/lib/esm/cbor.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// This file is based on:
// https://github.com/dfinity-lab/dfinity/blob/9bca65f8edd65701ea6bdb00e0752f9186bbc893/docs/spec/public/index.adoc#cbor-encoding-of-requests-and-responses
__turbopack_context__.s({
    "CborTag": (()=>CborTag),
    "decode": (()=>decode),
    "encode": (()=>encode)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$borc$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/borc/src/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$simple$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/simple-cbor/src/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/utils/buffer.js [app-ssr] (ecmascript)");
;
;
;
;
// We are using hansl/simple-cbor for CBOR serialization, to avoid issues with
// encoding the uint64 values that the HTTP handler of the client expects for
// canister IDs. However, simple-cbor does not yet provide deserialization so
// we are using `Uint8Array` so that we can use the dignifiedquire/borc CBOR
// decoder.
class PrincipalEncoder {
    get name() {
        return 'Principal';
    }
    get priority() {
        return 0;
    }
    match(value) {
        return value && value._isPrincipal === true;
    }
    encode(v) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$simple$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["value"].bytes(v.toUint8Array());
    }
}
class BufferEncoder {
    get name() {
        return 'Buffer';
    }
    get priority() {
        return 1;
    }
    match(value) {
        return value instanceof ArrayBuffer || ArrayBuffer.isView(value);
    }
    encode(v) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$simple$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["value"].bytes(new Uint8Array(v));
    }
}
class BigIntEncoder {
    get name() {
        return 'BigInt';
    }
    get priority() {
        return 1;
    }
    match(value) {
        return typeof value === `bigint`;
    }
    encode(v) {
        // Always use a bigint encoding.
        if (v > BigInt(0)) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$simple$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["value"].tagged(2, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$simple$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["value"].bytes((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fromHex"])(v.toString(16))));
        } else {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$simple$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["value"].tagged(3, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$simple$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["value"].bytes((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fromHex"])((BigInt('-1') * v).toString(16))));
        }
    }
}
const serializer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$simple$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SelfDescribeCborSerializer"].withDefaultEncoders(true);
serializer.addEncoder(new PrincipalEncoder());
serializer.addEncoder(new BufferEncoder());
serializer.addEncoder(new BigIntEncoder());
var CborTag;
(function(CborTag) {
    CborTag[CborTag["Uint64LittleEndian"] = 71] = "Uint64LittleEndian";
    CborTag[CborTag["Semantic"] = 55799] = "Semantic";
})(CborTag || (CborTag = {}));
function encode(value) {
    return serializer.serialize(value);
}
function decodePositiveBigInt(buf) {
    const len = buf.byteLength;
    let res = BigInt(0);
    for(let i = 0; i < len; i++){
        res = res * BigInt(0x100) + BigInt(buf[i]);
    }
    return res;
}
// A BORC subclass that decodes byte strings to ArrayBuffer instead of the Buffer class.
class Uint8ArrayDecoder extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$borc$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].Decoder {
    createByteString(raw) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["concat"])(...raw);
    }
    createByteStringFromHeap(start, end) {
        if (start === end) {
            return new ArrayBuffer(0);
        }
        return new Uint8Array(this._heap.slice(start, end));
    }
}
function decode(input) {
    const buffer = new Uint8Array(input);
    const decoder = new Uint8ArrayDecoder({
        size: buffer.byteLength,
        tags: {
            // Override tags 2 and 3 for BigInt support (borc supports only BigNumber).
            2: (val)=>decodePositiveBigInt(val),
            3: (val)=>-decodePositiveBigInt(val),
            [CborTag.Semantic]: (value)=>value
        }
    });
    try {
        return decoder.decodeFirst(buffer);
    } catch (e) {
        throw new Error(`Failed to decode CBOR: ${e}, input: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toHex"])(buffer)}`);
    }
} //# sourceMappingURL=cbor.js.map
}}),
"[project]/node_modules/@dfinity/agent/lib/esm/utils/random.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Generates a random unsigned 32-bit integer between 0 and 0xffffffff
 * @returns {number} a random number
 */ __turbopack_context__.s({
    "randomNumber": (()=>randomNumber)
});
const randomNumber = ()=>{
    // determine whether browser crypto is available
    if (typeof window !== 'undefined' && !!window.crypto && !!window.crypto.getRandomValues) {
        const array = new Uint32Array(1);
        window.crypto.getRandomValues(array);
        return array[0];
    }
    // A second check for webcrypto, in case it is loaded under global instead of window
    if (typeof crypto !== 'undefined' && crypto.getRandomValues) {
        const array = new Uint32Array(1);
        crypto.getRandomValues(array);
        return array[0];
    }
    // determine whether node crypto is available
    if (typeof crypto !== 'undefined' && crypto.randomInt) {
        return crypto.randomInt(0, 0xffffffff);
    }
    // fall back to Math.random
    return Math.floor(Math.random() * 0xffffffff);
}; //# sourceMappingURL=random.js.map
}}),
"[project]/node_modules/@dfinity/agent/lib/esm/agent/http/types.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "SubmitRequestType": (()=>SubmitRequestType),
    "makeNonce": (()=>makeNonce)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$random$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/utils/random.js [app-ssr] (ecmascript)");
;
var SubmitRequestType;
(function(SubmitRequestType) {
    SubmitRequestType["Call"] = "call";
})(SubmitRequestType || (SubmitRequestType = {}));
function makeNonce() {
    // Encode 128 bits.
    const buffer = new ArrayBuffer(16);
    const view = new DataView(buffer);
    const rand1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$random$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["randomNumber"])();
    const rand2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$random$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["randomNumber"])();
    const rand3 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$random$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["randomNumber"])();
    const rand4 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$random$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["randomNumber"])();
    view.setUint32(0, rand1);
    view.setUint32(4, rand2);
    view.setUint32(8, rand3);
    view.setUint32(12, rand4);
    return buffer;
} //# sourceMappingURL=types.js.map
}}),
"[project]/node_modules/@dfinity/agent/lib/esm/agent/http/transforms.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "Expiry": (()=>Expiry),
    "httpHeadersTransform": (()=>httpHeadersTransform),
    "makeExpiryTransform": (()=>makeExpiryTransform),
    "makeNonceTransform": (()=>makeNonceTransform)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$candid$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/candid/lib/esm/index.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$candid$2f$lib$2f$esm$2f$utils$2f$leb128$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/candid/lib/esm/utils/leb128.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$simple$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/simple-cbor/src/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/agent/http/types.js [app-ssr] (ecmascript)");
;
;
;
const NANOSECONDS_PER_MILLISECONDS = BigInt(1000000);
const REPLICA_PERMITTED_DRIFT_MILLISECONDS = 60 * 1000;
class Expiry {
    constructor(deltaInMSec){
        // if ingress as seconds is less than 90, round to nearest second
        if (deltaInMSec < 90 * 1000) {
            // Raw value without subtraction of REPLICA_PERMITTED_DRIFT_MILLISECONDS
            const raw_value = BigInt(Date.now() + deltaInMSec) * NANOSECONDS_PER_MILLISECONDS;
            const ingress_as_seconds = raw_value / BigInt(1000000000);
            this._value = ingress_as_seconds * BigInt(1000000000);
            return;
        }
        // Use bigint because it can overflow the maximum number allowed in a double float.
        const raw_value = BigInt(Math.floor(Date.now() + deltaInMSec - REPLICA_PERMITTED_DRIFT_MILLISECONDS)) * NANOSECONDS_PER_MILLISECONDS;
        // round down to the nearest second (since )
        const ingress_as_seconds = raw_value / BigInt(1000000000);
        // round down to nearest minute
        const ingress_as_minutes = ingress_as_seconds / BigInt(60);
        const rounded_down_nanos = ingress_as_minutes * BigInt(60) * BigInt(1000000000);
        this._value = rounded_down_nanos;
    }
    toCBOR() {
        // TODO: change this to take the minimum amount of space (it always takes 8 bytes now).
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$simple$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["value"].u64(this._value.toString(16), 16);
    }
    toHash() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$candid$2f$lib$2f$esm$2f$utils$2f$leb128$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lebEncode"])(this._value);
    }
}
function makeNonceTransform(nonceFn = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["makeNonce"]) {
    return async (request)=>{
        // Nonce needs to be inserted into the header for all requests, to enable logs to be correlated with requests.
        const headers = request.request.headers;
        // TODO: uncomment this when the http proxy supports it.
        // headers.set('X-IC-Request-ID', toHex(new Uint8Array(nonce)));
        request.request.headers = headers;
        // Nonce only needs to be inserted into the body for async calls, to prevent replay attacks.
        if (request.endpoint === "call" /* Endpoint.Call */ ) {
            request.body.nonce = nonceFn();
        }
    };
}
function makeExpiryTransform(delayInMilliseconds) {
    return async (request)=>{
        request.body.ingress_expiry = new Expiry(delayInMilliseconds);
    };
}
function httpHeadersTransform(headers) {
    const headerFields = [];
    headers.forEach((value, key)=>{
        headerFields.push([
            key,
            value
        ]);
    });
    return headerFields;
} //# sourceMappingURL=transforms.js.map
}}),
"[project]/node_modules/@dfinity/agent/lib/esm/agent/http/errors.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "AgentCallError": (()=>AgentCallError),
    "AgentHTTPResponseError": (()=>AgentHTTPResponseError),
    "AgentQueryError": (()=>AgentQueryError),
    "AgentReadStateError": (()=>AgentReadStateError)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/errors.js [app-ssr] (ecmascript)");
;
class AgentHTTPResponseError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AgentError"] {
    constructor(message, response){
        super(message);
        this.response = response;
        this.name = this.constructor.name;
        Object.setPrototypeOf(this, new.target.prototype);
    }
}
class AgentCallError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AgentError"] {
    constructor(message, response, requestId, senderPubkey, senderSig, ingressExpiry){
        super(message);
        this.response = response;
        this.requestId = requestId;
        this.senderPubkey = senderPubkey;
        this.senderSig = senderSig;
        this.ingressExpiry = ingressExpiry;
        this.name = 'AgentCallError';
        Object.setPrototypeOf(this, new.target.prototype);
    }
}
class AgentQueryError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AgentError"] {
    constructor(message, response, requestId, senderPubkey, senderSig, ingressExpiry){
        super(message);
        this.response = response;
        this.requestId = requestId;
        this.senderPubkey = senderPubkey;
        this.senderSig = senderSig;
        this.ingressExpiry = ingressExpiry;
        this.name = 'AgentQueryError';
        Object.setPrototypeOf(this, new.target.prototype);
    }
}
class AgentReadStateError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AgentError"] {
    constructor(message, response, requestId, senderPubkey, senderSig, ingressExpiry){
        super(message);
        this.response = response;
        this.requestId = requestId;
        this.senderPubkey = senderPubkey;
        this.senderSig = senderSig;
        this.ingressExpiry = ingressExpiry;
        this.name = 'AgentReadStateError';
        Object.setPrototypeOf(this, new.target.prototype);
    }
} //# sourceMappingURL=errors.js.map
}}),
"[project]/node_modules/@dfinity/agent/lib/esm/utils/bls.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "blsVerify": (()=>blsVerify),
    "verify": (()=>verify)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$bls12$2d$381$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/curves/esm/bls12-381.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/utils/buffer.js [app-ssr] (ecmascript)");
;
;
let verify;
function blsVerify(pk, sig, msg) {
    const primaryKey = typeof pk === 'string' ? pk : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toHex"])(pk);
    const signature = typeof sig === 'string' ? sig : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toHex"])(sig);
    const message = typeof msg === 'string' ? msg : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toHex"])(msg);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$bls12$2d$381$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bls12_381"].verifyShortSignature(signature, message, primaryKey);
} //# sourceMappingURL=bls.js.map
}}),
"[project]/node_modules/@dfinity/agent/lib/esm/utils/leb.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "decodeLeb128": (()=>decodeLeb128),
    "decodeTime": (()=>decodeTime)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$candid$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/candid/lib/esm/index.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$candid$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/candid/lib/esm/utils/buffer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$candid$2f$lib$2f$esm$2f$utils$2f$leb128$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/candid/lib/esm/utils/leb128.js [app-ssr] (ecmascript)");
;
const decodeLeb128 = (buf)=>{
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$candid$2f$lib$2f$esm$2f$utils$2f$leb128$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lebDecode"])(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$candid$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PipeArrayBuffer"](buf));
};
const decodeTime = (buf)=>{
    const decoded = decodeLeb128(buf);
    // nanoseconds to milliseconds
    return new Date(Number(decoded) / 1000000);
}; //# sourceMappingURL=leb.js.map
}}),
"[project]/node_modules/@dfinity/agent/lib/esm/utils/expirableMap.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "ExpirableMap": (()=>ExpirableMap)
});
var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ExpirableMap_inner, _ExpirableMap_expirationTime, _a, _b;
class ExpirableMap {
    /**
     * Create a new ExpirableMap.
     * @param {ExpirableMapOptions<any, any>} options - options for the map.
     * @param {Iterable<[any, any]>} options.source - an optional source of entries to initialize the map with.
     * @param {number} options.expirationTime - the time in milliseconds after which entries will expire.
     */ constructor(options = {}){
        // Internals
        _ExpirableMap_inner.set(this, void 0);
        _ExpirableMap_expirationTime.set(this, void 0);
        this[_a] = this.entries.bind(this);
        this[_b] = 'ExpirableMap';
        const { source = [], expirationTime = 10 * 60 * 1000 } = options;
        const currentTime = Date.now();
        __classPrivateFieldSet(this, _ExpirableMap_inner, new Map([
            ...source
        ].map(([key, value])=>[
                key,
                {
                    value,
                    timestamp: currentTime
                }
            ])), "f");
        __classPrivateFieldSet(this, _ExpirableMap_expirationTime, expirationTime, "f");
    }
    /**
     * Prune removes all expired entries.
     */ prune() {
        const currentTime = Date.now();
        for (const [key, entry] of __classPrivateFieldGet(this, _ExpirableMap_inner, "f").entries()){
            if (currentTime - entry.timestamp > __classPrivateFieldGet(this, _ExpirableMap_expirationTime, "f")) {
                __classPrivateFieldGet(this, _ExpirableMap_inner, "f").delete(key);
            }
        }
        return this;
    }
    // Implementing the Map interface
    /**
     * Set the value for the given key. Prunes expired entries.
     * @param key for the entry
     * @param value of the entry
     * @returns this
     */ set(key, value) {
        this.prune();
        const entry = {
            value,
            timestamp: Date.now()
        };
        __classPrivateFieldGet(this, _ExpirableMap_inner, "f").set(key, entry);
        return this;
    }
    /**
     * Get the value associated with the key, if it exists and has not expired.
     * @param key K
     * @returns the value associated with the key, or undefined if the key is not present or has expired.
     */ get(key) {
        const entry = __classPrivateFieldGet(this, _ExpirableMap_inner, "f").get(key);
        if (entry === undefined) {
            return undefined;
        }
        if (Date.now() - entry.timestamp > __classPrivateFieldGet(this, _ExpirableMap_expirationTime, "f")) {
            __classPrivateFieldGet(this, _ExpirableMap_inner, "f").delete(key);
            return undefined;
        }
        return entry.value;
    }
    /**
     * Clear all entries.
     */ clear() {
        __classPrivateFieldGet(this, _ExpirableMap_inner, "f").clear();
    }
    /**
     * Entries returns the entries of the map, without the expiration time.
     * @returns an iterator over the entries of the map.
     */ entries() {
        const iterator = __classPrivateFieldGet(this, _ExpirableMap_inner, "f").entries();
        const generator = function*() {
            for (const [key, value] of iterator){
                yield [
                    key,
                    value.value
                ];
            }
        };
        return generator();
    }
    /**
     * Values returns the values of the map, without the expiration time.
     * @returns an iterator over the values of the map.
     */ values() {
        const iterator = __classPrivateFieldGet(this, _ExpirableMap_inner, "f").values();
        const generator = function*() {
            for (const value of iterator){
                yield value.value;
            }
        };
        return generator();
    }
    /**
     * Keys returns the keys of the map
     * @returns an iterator over the keys of the map.
     */ keys() {
        return __classPrivateFieldGet(this, _ExpirableMap_inner, "f").keys();
    }
    /**
     * forEach calls the callbackfn on each entry of the map.
     * @param callbackfn to call on each entry
     * @param thisArg to use as this when calling the callbackfn
     */ forEach(callbackfn, thisArg) {
        for (const [key, value] of __classPrivateFieldGet(this, _ExpirableMap_inner, "f").entries()){
            callbackfn.call(thisArg, value.value, key, this);
        }
    }
    /**
     * has returns true if the key exists and has not expired.
     * @param key K
     * @returns true if the key exists and has not expired.
     */ has(key) {
        return __classPrivateFieldGet(this, _ExpirableMap_inner, "f").has(key);
    }
    /**
     * delete the entry for the given key.
     * @param key K
     * @returns true if the key existed and has been deleted.
     */ delete(key) {
        return __classPrivateFieldGet(this, _ExpirableMap_inner, "f").delete(key);
    }
    /**
     * get size of the map.
     * @returns the size of the map.
     */ get size() {
        return __classPrivateFieldGet(this, _ExpirableMap_inner, "f").size;
    }
}
_ExpirableMap_inner = new WeakMap(), _ExpirableMap_expirationTime = new WeakMap(), _a = Symbol.iterator, _b = Symbol.toStringTag; //# sourceMappingURL=expirableMap.js.map
}}),
"[project]/node_modules/@dfinity/agent/lib/esm/der.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "DER_COSE_OID": (()=>DER_COSE_OID),
    "ED25519_OID": (()=>ED25519_OID),
    "SECP256K1_OID": (()=>SECP256K1_OID),
    "decodeLen": (()=>decodeLen),
    "decodeLenBytes": (()=>decodeLenBytes),
    "encodeLen": (()=>encodeLen),
    "encodeLenBytes": (()=>encodeLenBytes),
    "unwrapDER": (()=>unwrapDER),
    "wrapDER": (()=>wrapDER)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/utils/buffer.js [app-ssr] (ecmascript)");
;
const encodeLenBytes = (len)=>{
    if (len <= 0x7f) {
        return 1;
    } else if (len <= 0xff) {
        return 2;
    } else if (len <= 0xffff) {
        return 3;
    } else if (len <= 0xffffff) {
        return 4;
    } else {
        throw new Error('Length too long (> 4 bytes)');
    }
};
const encodeLen = (buf, offset, len)=>{
    if (len <= 0x7f) {
        buf[offset] = len;
        return 1;
    } else if (len <= 0xff) {
        buf[offset] = 0x81;
        buf[offset + 1] = len;
        return 2;
    } else if (len <= 0xffff) {
        buf[offset] = 0x82;
        buf[offset + 1] = len >> 8;
        buf[offset + 2] = len;
        return 3;
    } else if (len <= 0xffffff) {
        buf[offset] = 0x83;
        buf[offset + 1] = len >> 16;
        buf[offset + 2] = len >> 8;
        buf[offset + 3] = len;
        return 4;
    } else {
        throw new Error('Length too long (> 4 bytes)');
    }
};
const decodeLenBytes = (buf, offset)=>{
    if (buf[offset] < 0x80) return 1;
    if (buf[offset] === 0x80) throw new Error('Invalid length 0');
    if (buf[offset] === 0x81) return 2;
    if (buf[offset] === 0x82) return 3;
    if (buf[offset] === 0x83) return 4;
    throw new Error('Length too long (> 4 bytes)');
};
const decodeLen = (buf, offset)=>{
    const lenBytes = decodeLenBytes(buf, offset);
    if (lenBytes === 1) return buf[offset];
    else if (lenBytes === 2) return buf[offset + 1];
    else if (lenBytes === 3) return (buf[offset + 1] << 8) + buf[offset + 2];
    else if (lenBytes === 4) return (buf[offset + 1] << 16) + (buf[offset + 2] << 8) + buf[offset + 3];
    throw new Error('Length too long (> 4 bytes)');
};
const DER_COSE_OID = Uint8Array.from([
    ...[
        0x30,
        0x0c
    ],
    ...[
        0x06,
        0x0a
    ],
    ...[
        0x2b,
        0x06,
        0x01,
        0x04,
        0x01,
        0x83,
        0xb8,
        0x43,
        0x01,
        0x01
    ]
]);
const ED25519_OID = Uint8Array.from([
    ...[
        0x30,
        0x05
    ],
    ...[
        0x06,
        0x03
    ],
    ...[
        0x2b,
        0x65,
        0x70
    ]
]);
const SECP256K1_OID = Uint8Array.from([
    ...[
        0x30,
        0x10
    ],
    ...[
        0x06,
        0x07
    ],
    ...[
        0x2a,
        0x86,
        0x48,
        0xce,
        0x3d,
        0x02,
        0x01
    ],
    ...[
        0x06,
        0x05
    ],
    ...[
        0x2b,
        0x81,
        0x04,
        0x00,
        0x0a
    ]
]);
function wrapDER(payload, oid) {
    // The Bit String header needs to include the unused bit count byte in its length
    const bitStringHeaderLength = 2 + encodeLenBytes(payload.byteLength + 1);
    const len = oid.byteLength + bitStringHeaderLength + payload.byteLength;
    let offset = 0;
    const buf = new Uint8Array(1 + encodeLenBytes(len) + len);
    // Sequence
    buf[offset++] = 0x30;
    // Sequence Length
    offset += encodeLen(buf, offset, len);
    // OID
    buf.set(oid, offset);
    offset += oid.byteLength;
    // Bit String Header
    buf[offset++] = 0x03;
    offset += encodeLen(buf, offset, payload.byteLength + 1);
    // 0 padding
    buf[offset++] = 0x00;
    buf.set(new Uint8Array(payload), offset);
    return buf;
}
const unwrapDER = (derEncoded, oid)=>{
    let offset = 0;
    const expect = (n, msg)=>{
        if (buf[offset++] !== n) {
            throw new Error('Expected: ' + msg);
        }
    };
    const buf = new Uint8Array(derEncoded);
    expect(0x30, 'sequence');
    offset += decodeLenBytes(buf, offset);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bufEquals"])(buf.slice(offset, offset + oid.byteLength), oid)) {
        throw new Error('Not the expected OID.');
    }
    offset += oid.byteLength;
    expect(0x03, 'bit string');
    const payloadLen = decodeLen(buf, offset) - 1; // Subtracting 1 to account for the 0 padding
    offset += decodeLenBytes(buf, offset);
    expect(0x00, '0 padding');
    const result = buf.slice(offset);
    if (payloadLen !== result.length) {
        throw new Error(`DER payload mismatch: Expected length ${payloadLen} actual length ${result.length}`);
    }
    return result;
}; //# sourceMappingURL=der.js.map
}}),
"[project]/node_modules/@dfinity/agent/lib/esm/public_key.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "Ed25519PublicKey": (()=>Ed25519PublicKey)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$der$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/der.js [app-ssr] (ecmascript)");
var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Ed25519PublicKey_rawKey, _Ed25519PublicKey_derKey;
;
class Ed25519PublicKey {
    // `fromRaw` and `fromDer` should be used for instantiation, not this constructor.
    constructor(key){
        _Ed25519PublicKey_rawKey.set(this, void 0);
        _Ed25519PublicKey_derKey.set(this, void 0);
        if (key.byteLength !== Ed25519PublicKey.RAW_KEY_LENGTH) {
            throw new Error('An Ed25519 public key must be exactly 32bytes long');
        }
        __classPrivateFieldSet(this, _Ed25519PublicKey_rawKey, key, "f");
        __classPrivateFieldSet(this, _Ed25519PublicKey_derKey, Ed25519PublicKey.derEncode(key), "f");
    }
    static from(key) {
        return this.fromDer(key.toDer());
    }
    static fromRaw(rawKey) {
        return new Ed25519PublicKey(rawKey);
    }
    static fromDer(derKey) {
        return new Ed25519PublicKey(this.derDecode(derKey));
    }
    static derEncode(publicKey) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$der$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["wrapDER"])(publicKey, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$der$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ED25519_OID"]).buffer;
    }
    static derDecode(key) {
        const unwrapped = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$der$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["unwrapDER"])(key, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$der$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ED25519_OID"]);
        if (unwrapped.length !== this.RAW_KEY_LENGTH) {
            throw new Error('An Ed25519 public key must be exactly 32bytes long');
        }
        return unwrapped;
    }
    get rawKey() {
        return __classPrivateFieldGet(this, _Ed25519PublicKey_rawKey, "f");
    }
    get derKey() {
        return __classPrivateFieldGet(this, _Ed25519PublicKey_derKey, "f");
    }
    toDer() {
        return this.derKey;
    }
    toRaw() {
        return this.rawKey;
    }
}
_Ed25519PublicKey_rawKey = new WeakMap(), _Ed25519PublicKey_derKey = new WeakMap();
// The length of Ed25519 public keys is always 32 bytes.
Ed25519PublicKey.RAW_KEY_LENGTH = 32; //# sourceMappingURL=public_key.js.map
}}),
"[project]/node_modules/@dfinity/agent/lib/esm/observable.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "Observable": (()=>Observable),
    "ObservableLog": (()=>ObservableLog)
});
class Observable {
    constructor(){
        this.observers = [];
    }
    subscribe(func) {
        this.observers.push(func);
    }
    unsubscribe(func) {
        this.observers = this.observers.filter((observer)=>observer !== func);
    }
    notify(data, ...rest) {
        this.observers.forEach((observer)=>observer(data, ...rest));
    }
}
class ObservableLog extends Observable {
    constructor(){
        super();
    }
    print(message, ...rest) {
        this.notify({
            message,
            level: 'info'
        }, ...rest);
    }
    warn(message, ...rest) {
        this.notify({
            message,
            level: 'warn'
        }, ...rest);
    }
    error(message, error, ...rest) {
        this.notify({
            message,
            level: 'error',
            error
        }, ...rest);
    }
} //# sourceMappingURL=observable.js.map
}}),
"[project]/node_modules/@dfinity/agent/lib/esm/polling/backoff.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "ExponentialBackoff": (()=>ExponentialBackoff),
    "exponentialBackoff": (()=>exponentialBackoff)
});
var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ExponentialBackoff_currentInterval, _ExponentialBackoff_randomizationFactor, _ExponentialBackoff_multiplier, _ExponentialBackoff_maxInterval, _ExponentialBackoff_startTime, _ExponentialBackoff_maxElapsedTime, _ExponentialBackoff_maxIterations, _ExponentialBackoff_date, _ExponentialBackoff_count;
const RANDOMIZATION_FACTOR = 0.5;
const MULTIPLIER = 1.5;
const INITIAL_INTERVAL_MSEC = 500;
const MAX_INTERVAL_MSEC = 60000;
const MAX_ELAPSED_TIME_MSEC = 900000;
const MAX_ITERATIONS = 10;
class ExponentialBackoff {
    constructor(options = ExponentialBackoff.default){
        _ExponentialBackoff_currentInterval.set(this, void 0);
        _ExponentialBackoff_randomizationFactor.set(this, void 0);
        _ExponentialBackoff_multiplier.set(this, void 0);
        _ExponentialBackoff_maxInterval.set(this, void 0);
        _ExponentialBackoff_startTime.set(this, void 0);
        _ExponentialBackoff_maxElapsedTime.set(this, void 0);
        _ExponentialBackoff_maxIterations.set(this, void 0);
        _ExponentialBackoff_date.set(this, void 0);
        _ExponentialBackoff_count.set(this, 0);
        const { initialInterval = INITIAL_INTERVAL_MSEC, randomizationFactor = RANDOMIZATION_FACTOR, multiplier = MULTIPLIER, maxInterval = MAX_INTERVAL_MSEC, maxElapsedTime = MAX_ELAPSED_TIME_MSEC, maxIterations = MAX_ITERATIONS, date = Date } = options;
        __classPrivateFieldSet(this, _ExponentialBackoff_currentInterval, initialInterval, "f");
        __classPrivateFieldSet(this, _ExponentialBackoff_randomizationFactor, randomizationFactor, "f");
        __classPrivateFieldSet(this, _ExponentialBackoff_multiplier, multiplier, "f");
        __classPrivateFieldSet(this, _ExponentialBackoff_maxInterval, maxInterval, "f");
        __classPrivateFieldSet(this, _ExponentialBackoff_date, date, "f");
        __classPrivateFieldSet(this, _ExponentialBackoff_startTime, date.now(), "f");
        __classPrivateFieldSet(this, _ExponentialBackoff_maxElapsedTime, maxElapsedTime, "f");
        __classPrivateFieldSet(this, _ExponentialBackoff_maxIterations, maxIterations, "f");
    }
    get ellapsedTimeInMsec() {
        return __classPrivateFieldGet(this, _ExponentialBackoff_date, "f").now() - __classPrivateFieldGet(this, _ExponentialBackoff_startTime, "f");
    }
    get currentInterval() {
        return __classPrivateFieldGet(this, _ExponentialBackoff_currentInterval, "f");
    }
    get count() {
        return __classPrivateFieldGet(this, _ExponentialBackoff_count, "f");
    }
    get randomValueFromInterval() {
        const delta = __classPrivateFieldGet(this, _ExponentialBackoff_randomizationFactor, "f") * __classPrivateFieldGet(this, _ExponentialBackoff_currentInterval, "f");
        const min = __classPrivateFieldGet(this, _ExponentialBackoff_currentInterval, "f") - delta;
        const max = __classPrivateFieldGet(this, _ExponentialBackoff_currentInterval, "f") + delta;
        return Math.random() * (max - min) + min;
    }
    incrementCurrentInterval() {
        var _a;
        __classPrivateFieldSet(this, _ExponentialBackoff_currentInterval, Math.min(__classPrivateFieldGet(this, _ExponentialBackoff_currentInterval, "f") * __classPrivateFieldGet(this, _ExponentialBackoff_multiplier, "f"), __classPrivateFieldGet(this, _ExponentialBackoff_maxInterval, "f")), "f");
        __classPrivateFieldSet(this, _ExponentialBackoff_count, (_a = __classPrivateFieldGet(this, _ExponentialBackoff_count, "f"), _a++, _a), "f");
        return __classPrivateFieldGet(this, _ExponentialBackoff_currentInterval, "f");
    }
    next() {
        if (this.ellapsedTimeInMsec >= __classPrivateFieldGet(this, _ExponentialBackoff_maxElapsedTime, "f") || __classPrivateFieldGet(this, _ExponentialBackoff_count, "f") >= __classPrivateFieldGet(this, _ExponentialBackoff_maxIterations, "f")) {
            return null;
        } else {
            this.incrementCurrentInterval();
            return this.randomValueFromInterval;
        }
    }
}
_ExponentialBackoff_currentInterval = new WeakMap(), _ExponentialBackoff_randomizationFactor = new WeakMap(), _ExponentialBackoff_multiplier = new WeakMap(), _ExponentialBackoff_maxInterval = new WeakMap(), _ExponentialBackoff_startTime = new WeakMap(), _ExponentialBackoff_maxElapsedTime = new WeakMap(), _ExponentialBackoff_maxIterations = new WeakMap(), _ExponentialBackoff_date = new WeakMap(), _ExponentialBackoff_count = new WeakMap();
ExponentialBackoff.default = {
    initialInterval: INITIAL_INTERVAL_MSEC,
    randomizationFactor: RANDOMIZATION_FACTOR,
    multiplier: MULTIPLIER,
    maxInterval: MAX_INTERVAL_MSEC,
    // 1 minute
    maxElapsedTime: MAX_ELAPSED_TIME_MSEC,
    maxIterations: MAX_ITERATIONS,
    date: Date
};
function* exponentialBackoff(options = ExponentialBackoff.default) {
    const backoff = new ExponentialBackoff(options);
    let next = backoff.next();
    while(next){
        yield next;
        next = backoff.next();
    }
} //# sourceMappingURL=backoff.js.map
}}),
"[project]/node_modules/@dfinity/agent/lib/esm/agent/http/index.js [app-ssr] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "HttpAgent": (()=>HttpAgent),
    "IC_ROOT_KEY": (()=>IC_ROOT_KEY),
    "IdentityInvalidError": (()=>IdentityInvalidError),
    "MANAGEMENT_CANISTER_ID": (()=>MANAGEMENT_CANISTER_ID),
    "RequestStatusResponseStatus": (()=>RequestStatusResponseStatus)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/principal/lib/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/errors.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$auth$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/auth.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$cbor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/cbor.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$request_id$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/request_id.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/utils/buffer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$transforms$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/agent/http/transforms.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/agent/http/types.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/agent/http/errors.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$canisterStatus$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/canisterStatus/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$certificate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/certificate.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$ed25519$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/curves/esm/ed25519.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$expirableMap$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/utils/expirableMap.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$public_key$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/public_key.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$leb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/utils/leb.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/observable.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$polling$2f$backoff$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/polling/backoff.js [app-ssr] (ecmascript)");
var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _HttpAgent_instances, _HttpAgent_rootKeyPromise, _HttpAgent_shouldFetchRootKey, _HttpAgent_identity, _HttpAgent_fetch, _HttpAgent_fetchOptions, _HttpAgent_callOptions, _HttpAgent_timeDiffMsecs, _HttpAgent_credentials, _HttpAgent_retryTimes, _HttpAgent_backoffStrategy, _HttpAgent_maxIngressExpiryInMinutes, _HttpAgent_waterMark, _HttpAgent_queryPipeline, _HttpAgent_updatePipeline, _HttpAgent_subnetKeys, _HttpAgent_verifyQuerySignatures, _HttpAgent_requestAndRetryQuery, _HttpAgent_requestAndRetry, _HttpAgent_verifyQueryResponse, _HttpAgent_rootKeyGuard;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
var RequestStatusResponseStatus;
(function(RequestStatusResponseStatus) {
    RequestStatusResponseStatus["Received"] = "received";
    RequestStatusResponseStatus["Processing"] = "processing";
    RequestStatusResponseStatus["Replied"] = "replied";
    RequestStatusResponseStatus["Rejected"] = "rejected";
    RequestStatusResponseStatus["Unknown"] = "unknown";
    RequestStatusResponseStatus["Done"] = "done";
})(RequestStatusResponseStatus || (RequestStatusResponseStatus = {}));
const MINUTE_TO_MSECS = 60 * 1000;
const IC_ROOT_KEY = '308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100814' + 'c0e6ec71fab583b08bd81373c255c3c371b2e84863c98a4f1e08b74235d14fb5d9c0cd546d968' + '5f913a0c0b2cc5341583bf4b4392e467db96d65b9bb4cb717112f8472e0d5a4d14505ffd7484' + 'b01291091c5f87b98883463f98091a0baaae';
const MANAGEMENT_CANISTER_ID = 'aaaaa-aa';
// IC0 domain info
const IC0_DOMAIN = 'ic0.app';
const IC0_SUB_DOMAIN = '.ic0.app';
const ICP0_DOMAIN = 'icp0.io';
const ICP0_SUB_DOMAIN = '.icp0.io';
const ICP_API_DOMAIN = 'icp-api.io';
const ICP_API_SUB_DOMAIN = '.icp-api.io';
class HttpDefaultFetchError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AgentError"] {
    constructor(message){
        super(message);
        this.message = message;
    }
}
class IdentityInvalidError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AgentError"] {
    constructor(message){
        super(message);
        this.message = message;
    }
}
function getDefaultFetch() {
    let defaultFetch;
    if (typeof window !== 'undefined') {
        // Browser context
        if (window.fetch) {
            defaultFetch = window.fetch.bind(window);
        } else {
            throw new HttpDefaultFetchError('Fetch implementation was not available. You appear to be in a browser context, but window.fetch was not present.');
        }
    } else if (typeof global !== 'undefined') {
        // Node context
        if (global.fetch) {
            defaultFetch = global.fetch.bind(global);
        } else {
            throw new HttpDefaultFetchError('Fetch implementation was not available. You appear to be in a Node.js context, but global.fetch was not available.');
        }
    } else if (typeof self !== 'undefined') {
        if (self.fetch) {
            defaultFetch = self.fetch.bind(self);
        }
    }
    if (defaultFetch) {
        return defaultFetch;
    }
    throw new HttpDefaultFetchError('Fetch implementation was not available. Please provide fetch to the HttpAgent constructor, or ensure it is available in the window or global context.');
}
function determineHost(configuredHost) {
    let host;
    if (configuredHost !== undefined) {
        if (!configuredHost.match(/^[a-z]+:/) && typeof window !== 'undefined') {
            host = new URL(window.location.protocol + '//' + configuredHost);
        } else {
            host = new URL(configuredHost);
        }
    } else {
        // Mainnet, local, and remote environments will have the api route available
        const knownHosts = [
            'ic0.app',
            'icp0.io',
            '127.0.0.1',
            'localhost'
        ];
        const remoteHosts = [
            '.github.dev',
            '.gitpod.io'
        ];
        const location = typeof window !== 'undefined' ? window.location : undefined;
        const hostname = location === null || location === void 0 ? void 0 : location.hostname;
        let knownHost;
        if (hostname && typeof hostname === 'string') {
            if (remoteHosts.some((host)=>hostname.endsWith(host))) {
                knownHost = hostname;
            } else {
                knownHost = knownHosts.find((host)=>hostname.endsWith(host));
            }
        }
        if (location && knownHost) {
            // If the user is on a boundary-node provided host, we can use the same host for the agent
            host = new URL(`${location.protocol}//${knownHost}${location.port ? ':' + location.port : ''}`);
        } else {
            host = new URL('https://icp-api.io');
        }
    }
    return host.toString();
}
class HttpAgent {
    /**
     * @param options - Options for the HttpAgent
     * @deprecated Use `HttpAgent.create` or `HttpAgent.createSync` instead
     */ constructor(options = {}){
        var _a, _b;
        _HttpAgent_instances.add(this);
        _HttpAgent_rootKeyPromise.set(this, null);
        _HttpAgent_shouldFetchRootKey.set(this, false);
        _HttpAgent_identity.set(this, void 0);
        _HttpAgent_fetch.set(this, void 0);
        _HttpAgent_fetchOptions.set(this, void 0);
        _HttpAgent_callOptions.set(this, void 0);
        _HttpAgent_timeDiffMsecs.set(this, 0);
        _HttpAgent_credentials.set(this, void 0);
        _HttpAgent_retryTimes.set(this, void 0); // Retry requests N times before erroring by default
        _HttpAgent_backoffStrategy.set(this, void 0);
        _HttpAgent_maxIngressExpiryInMinutes.set(this, void 0);
        // Public signature to help with type checking.
        this._isAgent = true;
        this.config = {};
        // The UTC time in milliseconds when the latest request was made
        _HttpAgent_waterMark.set(this, 0);
        this.log = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ObservableLog"]();
        _HttpAgent_queryPipeline.set(this, []);
        _HttpAgent_updatePipeline.set(this, []);
        _HttpAgent_subnetKeys.set(this, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$expirableMap$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExpirableMap"]({
            expirationTime: 5 * 60 * 1000
        }));
        _HttpAgent_verifyQuerySignatures.set(this, true);
        /**
         * See https://internetcomputer.org/docs/current/references/ic-interface-spec/#http-query for details on validation
         * @param queryResponse - The response from the query
         * @param subnetStatus - The subnet status, including all node keys
         * @returns ApiQueryResponse
         */ _HttpAgent_verifyQueryResponse.set(this, (queryResponse, subnetStatus)=>{
            if (__classPrivateFieldGet(this, _HttpAgent_verifyQuerySignatures, "f") === false) {
                // This should not be called if the user has disabled verification
                return queryResponse;
            }
            if (!subnetStatus) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$certificate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CertificateVerificationError"]('Invalid signature from replica signed query: no matching node key found.');
            }
            const { status, signatures = [], requestId } = queryResponse;
            const domainSeparator = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bufFromBufLike"])(new TextEncoder().encode('\x0Bic-response'));
            for (const sig of signatures){
                const { timestamp, identity } = sig;
                const nodeId = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Principal"].fromUint8Array(identity).toText();
                let hash;
                // Hash is constructed differently depending on the status
                if (status === 'replied') {
                    const { reply } = queryResponse;
                    hash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$request_id$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hashOfMap"])({
                        status: status,
                        reply: reply,
                        timestamp: BigInt(timestamp),
                        request_id: requestId
                    });
                } else if (status === 'rejected') {
                    const { reject_code, reject_message, error_code } = queryResponse;
                    hash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$request_id$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hashOfMap"])({
                        status: status,
                        reject_code: reject_code,
                        reject_message: reject_message,
                        error_code: error_code,
                        timestamp: BigInt(timestamp),
                        request_id: requestId
                    });
                } else {
                    throw new Error(`Unknown status: ${status}`);
                }
                const separatorWithHash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["concat"])(domainSeparator, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bufFromBufLike"])(new Uint8Array(hash)));
                // FIX: check for match without verifying N times
                const pubKey = subnetStatus === null || subnetStatus === void 0 ? void 0 : subnetStatus.nodeKeys.get(nodeId);
                if (!pubKey) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$certificate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CertificateVerificationError"]('Invalid signature from replica signed query: no matching node key found.');
                }
                const rawKey = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$public_key$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Ed25519PublicKey"].fromDer(pubKey).rawKey;
                const valid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$ed25519$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ed25519"].verify(sig.signature, new Uint8Array(separatorWithHash), new Uint8Array(rawKey));
                if (valid) return queryResponse;
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$certificate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CertificateVerificationError"](`Invalid signature from replica ${nodeId} signed query.`);
            }
            return queryResponse;
        });
        this.config = options;
        __classPrivateFieldSet(this, _HttpAgent_fetch, options.fetch || getDefaultFetch() || fetch.bind(global), "f");
        __classPrivateFieldSet(this, _HttpAgent_fetchOptions, options.fetchOptions, "f");
        __classPrivateFieldSet(this, _HttpAgent_callOptions, options.callOptions, "f");
        __classPrivateFieldSet(this, _HttpAgent_shouldFetchRootKey, (_a = options.shouldFetchRootKey) !== null && _a !== void 0 ? _a : false, "f");
        // Use provided root key, otherwise fall back to IC_ROOT_KEY for mainnet or null if the key needs to be fetched
        if (options.rootKey) {
            this.rootKey = options.rootKey;
        } else if (__classPrivateFieldGet(this, _HttpAgent_shouldFetchRootKey, "f")) {
            this.rootKey = null;
        } else {
            this.rootKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fromHex"])(IC_ROOT_KEY);
        }
        const host = determineHost(options.host);
        this.host = new URL(host);
        if (options.verifyQuerySignatures !== undefined) {
            __classPrivateFieldSet(this, _HttpAgent_verifyQuerySignatures, options.verifyQuerySignatures, "f");
        }
        // Default is 3
        __classPrivateFieldSet(this, _HttpAgent_retryTimes, (_b = options.retryTimes) !== null && _b !== void 0 ? _b : 3, "f");
        // Delay strategy for retries. Default is exponential backoff
        const defaultBackoffFactory = ()=>new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$polling$2f$backoff$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExponentialBackoff"]({
                maxIterations: __classPrivateFieldGet(this, _HttpAgent_retryTimes, "f")
            });
        __classPrivateFieldSet(this, _HttpAgent_backoffStrategy, options.backoffStrategy || defaultBackoffFactory, "f");
        // Rewrite to avoid redirects
        if (this.host.hostname.endsWith(IC0_SUB_DOMAIN)) {
            this.host.hostname = IC0_DOMAIN;
        } else if (this.host.hostname.endsWith(ICP0_SUB_DOMAIN)) {
            this.host.hostname = ICP0_DOMAIN;
        } else if (this.host.hostname.endsWith(ICP_API_SUB_DOMAIN)) {
            this.host.hostname = ICP_API_DOMAIN;
        }
        if (options.credentials) {
            const { name, password } = options.credentials;
            __classPrivateFieldSet(this, _HttpAgent_credentials, `${name}${password ? ':' + password : ''}`, "f");
        }
        __classPrivateFieldSet(this, _HttpAgent_identity, Promise.resolve(options.identity || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$auth$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AnonymousIdentity"]()), "f");
        if (options.ingressExpiryInMinutes && options.ingressExpiryInMinutes > 5) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AgentError"](`The maximum ingress expiry time is 5 minutes. Provided ingress expiry time is ${options.ingressExpiryInMinutes} minutes.`);
        }
        if (options.ingressExpiryInMinutes && options.ingressExpiryInMinutes <= 0) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AgentError"](`Ingress expiry time must be greater than 0. Provided ingress expiry time is ${options.ingressExpiryInMinutes} minutes.`);
        }
        __classPrivateFieldSet(this, _HttpAgent_maxIngressExpiryInMinutes, options.ingressExpiryInMinutes || 5, "f");
        // Add a nonce transform to ensure calls are unique
        this.addTransform('update', (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$transforms$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["makeNonceTransform"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["makeNonce"]));
        if (options.useQueryNonces) {
            this.addTransform('query', (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$transforms$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["makeNonceTransform"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["makeNonce"]));
        }
        if (options.logToConsole) {
            this.log.subscribe((log)=>{
                if (log.level === 'error') {
                    console.error(log.message);
                } else if (log.level === 'warn') {
                    console.warn(log.message);
                } else {
                    console.log(log.message);
                }
            });
        }
    }
    get waterMark() {
        return __classPrivateFieldGet(this, _HttpAgent_waterMark, "f");
    }
    static createSync(options = {}) {
        return new this(Object.assign({}, options));
    }
    static async create(options = {
        shouldFetchRootKey: false
    }) {
        const agent = HttpAgent.createSync(options);
        const initPromises = [
            agent.syncTime()
        ];
        if (agent.host.toString() !== 'https://icp-api.io' && options.shouldFetchRootKey) {
            initPromises.push(agent.fetchRootKey());
        }
        await Promise.all(initPromises);
        return agent;
    }
    static async from(agent) {
        var _a;
        try {
            if ('config' in agent) {
                return await HttpAgent.create(agent.config);
            }
            return await HttpAgent.create({
                fetch: agent._fetch,
                fetchOptions: agent._fetchOptions,
                callOptions: agent._callOptions,
                host: agent._host.toString(),
                identity: (_a = agent._identity) !== null && _a !== void 0 ? _a : undefined
            });
        } catch (_b) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AgentError"]('Failed to create agent from provided agent');
        }
    }
    isLocal() {
        const hostname = this.host.hostname;
        return hostname === '127.0.0.1' || hostname.endsWith('127.0.0.1');
    }
    addTransform(type, fn, priority = fn.priority || 0) {
        if (type === 'update') {
            // Keep the pipeline sorted at all time, by priority.
            const i = __classPrivateFieldGet(this, _HttpAgent_updatePipeline, "f").findIndex((x)=>(x.priority || 0) < priority);
            __classPrivateFieldGet(this, _HttpAgent_updatePipeline, "f").splice(i >= 0 ? i : __classPrivateFieldGet(this, _HttpAgent_updatePipeline, "f").length, 0, Object.assign(fn, {
                priority
            }));
        } else if (type === 'query') {
            // Keep the pipeline sorted at all time, by priority.
            const i = __classPrivateFieldGet(this, _HttpAgent_queryPipeline, "f").findIndex((x)=>(x.priority || 0) < priority);
            __classPrivateFieldGet(this, _HttpAgent_queryPipeline, "f").splice(i >= 0 ? i : __classPrivateFieldGet(this, _HttpAgent_queryPipeline, "f").length, 0, Object.assign(fn, {
                priority
            }));
        }
    }
    async getPrincipal() {
        if (!__classPrivateFieldGet(this, _HttpAgent_identity, "f")) {
            throw new IdentityInvalidError("This identity has expired due this application's security policy. Please refresh your authentication.");
        }
        return (await __classPrivateFieldGet(this, _HttpAgent_identity, "f")).getPrincipal();
    }
    /**
     * Makes a call to a canister method.
     * @param canisterId - The ID of the canister to call. Can be a Principal or a string.
     * @param options - Options for the call.
     * @param options.methodName - The name of the method to call.
     * @param options.arg - The argument to pass to the method, as an ArrayBuffer.
     * @param options.effectiveCanisterId - (Optional) The effective canister ID, if different from the target canister ID.
     * @param options.callSync - (Optional) Whether to use synchronous call mode. Defaults to true.
     * @param options.nonce - (Optional) A unique nonce for the request. If provided, it will override any nonce set by transforms.
     * @param identity - (Optional) The identity to use for the call. If not provided, the agent's current identity will be used.
     * @returns A promise that resolves to the response of the call, including the request ID and response details.
     */ async call(canisterId, options, identity) {
        var _a, _b;
        await __classPrivateFieldGet(this, _HttpAgent_instances, "m", _HttpAgent_rootKeyGuard).call(this);
        // TODO - restore this value
        const callSync = (_a = options.callSync) !== null && _a !== void 0 ? _a : true;
        const id = await (identity !== undefined ? await identity : await __classPrivateFieldGet(this, _HttpAgent_identity, "f"));
        if (!id) {
            throw new IdentityInvalidError("This identity has expired due this application's security policy. Please refresh your authentication.");
        }
        const canister = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Principal"].from(canisterId);
        const ecid = options.effectiveCanisterId ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Principal"].from(options.effectiveCanisterId) : canister;
        const sender = id.getPrincipal() || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Principal"].anonymous();
        let ingress_expiry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$transforms$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Expiry"](__classPrivateFieldGet(this, _HttpAgent_maxIngressExpiryInMinutes, "f") * MINUTE_TO_MSECS);
        // If the value is off by more than 30 seconds, reconcile system time with the network
        if (Math.abs(__classPrivateFieldGet(this, _HttpAgent_timeDiffMsecs, "f")) > 1000 * 30) {
            ingress_expiry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$transforms$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Expiry"](__classPrivateFieldGet(this, _HttpAgent_maxIngressExpiryInMinutes, "f") * MINUTE_TO_MSECS + __classPrivateFieldGet(this, _HttpAgent_timeDiffMsecs, "f"));
        }
        const submit = {
            request_type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SubmitRequestType"].Call,
            canister_id: canister,
            method_name: options.methodName,
            arg: options.arg,
            sender,
            ingress_expiry
        };
        let transformedRequest = await this._transform({
            request: {
                body: null,
                method: 'POST',
                headers: Object.assign({
                    'Content-Type': 'application/cbor'
                }, __classPrivateFieldGet(this, _HttpAgent_credentials, "f") ? {
                    Authorization: 'Basic ' + btoa(__classPrivateFieldGet(this, _HttpAgent_credentials, "f"))
                } : {})
            },
            endpoint: "call" /* Endpoint.Call */ ,
            body: submit
        });
        // Determine the nonce to use for the request
        let nonce;
        // Check if a nonce is provided in the options and convert it to the correct type
        if (options === null || options === void 0 ? void 0 : options.nonce) {
            nonce = toNonce(options.nonce);
        } else if (transformedRequest.body.nonce) {
            nonce = toNonce(transformedRequest.body.nonce);
        } else {
            nonce = undefined;
        }
        // Assign the determined nonce to the submit object
        submit.nonce = nonce;
        /**
         * Converts an ArrayBuffer or Uint8Array to a Nonce type.
         * @param buf - The buffer to convert.
         * @returns The buffer as a Nonce.
         */ function toNonce(buf) {
            return new Uint8Array(buf);
        }
        // Apply transform for identity.
        transformedRequest = await id.transformRequest(transformedRequest);
        const body = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$cbor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encode"])(transformedRequest.body);
        const backoff = __classPrivateFieldGet(this, _HttpAgent_backoffStrategy, "f").call(this);
        const requestId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$request_id$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["requestIdOf"])(submit);
        try {
            // Attempt v3 sync call
            const requestSync = ()=>{
                this.log.print(`fetching "/api/v3/canister/${ecid.toText()}/call" with request:`, transformedRequest);
                return __classPrivateFieldGet(this, _HttpAgent_fetch, "f").call(this, '' + new URL(`/api/v3/canister/${ecid.toText()}/call`, this.host), Object.assign(Object.assign(Object.assign({}, __classPrivateFieldGet(this, _HttpAgent_callOptions, "f")), transformedRequest.request), {
                    body
                }));
            };
            const requestAsync = ()=>{
                this.log.print(`fetching "/api/v2/canister/${ecid.toText()}/call" with request:`, transformedRequest);
                return __classPrivateFieldGet(this, _HttpAgent_fetch, "f").call(this, '' + new URL(`/api/v2/canister/${ecid.toText()}/call`, this.host), Object.assign(Object.assign(Object.assign({}, __classPrivateFieldGet(this, _HttpAgent_callOptions, "f")), transformedRequest.request), {
                    body
                }));
            };
            const request = __classPrivateFieldGet(this, _HttpAgent_instances, "m", _HttpAgent_requestAndRetry).call(this, {
                request: callSync ? requestSync : requestAsync,
                backoff,
                tries: 0
            });
            const response = await request;
            const responseBuffer = await response.arrayBuffer();
            const responseBody = response.status === 200 && responseBuffer.byteLength > 0 ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$cbor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decode"])(responseBuffer) : null;
            // Update the watermark with the latest time from consensus
            if (responseBody && 'certificate' in responseBody) {
                const time = await this.parseTimeFromResponse({
                    certificate: responseBody.certificate
                });
                __classPrivateFieldSet(this, _HttpAgent_waterMark, time, "f");
            }
            return {
                requestId,
                response: {
                    ok: response.ok,
                    status: response.status,
                    statusText: response.statusText,
                    body: responseBody,
                    headers: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$transforms$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["httpHeadersTransform"])(response.headers)
                },
                requestDetails: submit
            };
        } catch (error) {
            // If the error is due to the v3 api not being supported, fall back to v2
            if (error.message.includes('v3 api not supported.')) {
                this.log.warn('v3 api not supported. Fall back to v2');
                return this.call(canisterId, Object.assign(Object.assign({}, options), {
                    // disable v3 api
                    callSync: false
                }), identity);
            }
            const message = `Error while making call: ${(_b = error.message) !== null && _b !== void 0 ? _b : String(error)}`;
            const callError = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AgentCallError"](message, error, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toHex"])(requestId), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toHex"])(transformedRequest.body.sender_pubkey), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toHex"])(transformedRequest.body.sender_sig), String(transformedRequest.body.content.ingress_expiry['_value']));
            this.log.error(message, callError);
            throw callError;
        }
    }
    async query(canisterId, fields, identity) {
        var _a, _b, _c, _d;
        await __classPrivateFieldGet(this, _HttpAgent_instances, "m", _HttpAgent_rootKeyGuard).call(this);
        const backoff = __classPrivateFieldGet(this, _HttpAgent_backoffStrategy, "f").call(this);
        const ecid = fields.effectiveCanisterId ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Principal"].from(fields.effectiveCanisterId) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Principal"].from(canisterId);
        this.log.print(`ecid ${ecid.toString()}`);
        this.log.print(`canisterId ${canisterId.toString()}`);
        let transformedRequest = undefined;
        let queryResult;
        const id = await (identity !== undefined ? identity : __classPrivateFieldGet(this, _HttpAgent_identity, "f"));
        if (!id) {
            throw new IdentityInvalidError("This identity has expired due this application's security policy. Please refresh your authentication.");
        }
        const canister = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Principal"].from(canisterId);
        const sender = (id === null || id === void 0 ? void 0 : id.getPrincipal()) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Principal"].anonymous();
        const request = {
            request_type: "query" /* ReadRequestType.Query */ ,
            canister_id: canister,
            method_name: fields.methodName,
            arg: fields.arg,
            sender,
            ingress_expiry: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$transforms$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Expiry"](__classPrivateFieldGet(this, _HttpAgent_maxIngressExpiryInMinutes, "f") * MINUTE_TO_MSECS)
        };
        const requestId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$request_id$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["requestIdOf"])(request);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        transformedRequest = await this._transform({
            request: {
                method: 'POST',
                headers: Object.assign({
                    'Content-Type': 'application/cbor'
                }, __classPrivateFieldGet(this, _HttpAgent_credentials, "f") ? {
                    Authorization: 'Basic ' + btoa(__classPrivateFieldGet(this, _HttpAgent_credentials, "f"))
                } : {})
            },
            endpoint: "read" /* Endpoint.Query */ ,
            body: request
        });
        // Apply transform for identity.
        transformedRequest = await (id === null || id === void 0 ? void 0 : id.transformRequest(transformedRequest));
        const body = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$cbor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encode"])(transformedRequest.body);
        const args = {
            canister: canister.toText(),
            ecid,
            transformedRequest,
            body,
            requestId,
            backoff,
            tries: 0
        };
        const makeQuery = async ()=>{
            return {
                requestDetails: request,
                query: await __classPrivateFieldGet(this, _HttpAgent_instances, "m", _HttpAgent_requestAndRetryQuery).call(this, args)
            };
        };
        const getSubnetStatus = async ()=>{
            if (!__classPrivateFieldGet(this, _HttpAgent_verifyQuerySignatures, "f")) {
                return undefined;
            }
            const subnetStatus = __classPrivateFieldGet(this, _HttpAgent_subnetKeys, "f").get(ecid.toString());
            if (subnetStatus) {
                return subnetStatus;
            }
            await this.fetchSubnetKeys(ecid.toString());
            return __classPrivateFieldGet(this, _HttpAgent_subnetKeys, "f").get(ecid.toString());
        };
        // Attempt to make the query i=retryTimes times
        // Make query and fetch subnet keys in parallel
        try {
            const [_queryResult, subnetStatus] = await Promise.all([
                makeQuery(),
                getSubnetStatus()
            ]);
            queryResult = _queryResult;
            const { requestDetails, query } = queryResult;
            const queryWithDetails = Object.assign(Object.assign({}, query), {
                requestDetails
            });
            this.log.print('Query response:', queryWithDetails);
            // Skip verification if the user has disabled it
            if (!__classPrivateFieldGet(this, _HttpAgent_verifyQuerySignatures, "f")) {
                return queryWithDetails;
            }
            try {
                return __classPrivateFieldGet(this, _HttpAgent_verifyQueryResponse, "f").call(this, queryWithDetails, subnetStatus);
            } catch (_e) {
                // In case the node signatures have changed, refresh the subnet keys and try again
                this.log.warn('Query response verification failed. Retrying with fresh subnet keys.');
                __classPrivateFieldGet(this, _HttpAgent_subnetKeys, "f").delete(canisterId.toString());
                await this.fetchSubnetKeys(ecid.toString());
                const updatedSubnetStatus = __classPrivateFieldGet(this, _HttpAgent_subnetKeys, "f").get(canisterId.toString());
                if (!updatedSubnetStatus) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$certificate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CertificateVerificationError"]('Invalid signature from replica signed query: no matching node key found.');
                }
                return __classPrivateFieldGet(this, _HttpAgent_verifyQueryResponse, "f").call(this, queryWithDetails, updatedSubnetStatus);
            }
        } catch (error) {
            const message = `Error while making call: ${(_a = error.message) !== null && _a !== void 0 ? _a : String(error)}`;
            const queryError = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AgentQueryError"](message, error, String(requestId), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toHex"])((_b = transformedRequest === null || transformedRequest === void 0 ? void 0 : transformedRequest.body) === null || _b === void 0 ? void 0 : _b.sender_pubkey), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toHex"])((_c = transformedRequest === null || transformedRequest === void 0 ? void 0 : transformedRequest.body) === null || _c === void 0 ? void 0 : _c.sender_sig), String((_d = transformedRequest === null || transformedRequest === void 0 ? void 0 : transformedRequest.body) === null || _d === void 0 ? void 0 : _d.content.ingress_expiry['_value']));
            this.log.error(message, queryError);
            throw queryError;
        }
    }
    async createReadStateRequest(fields, identity) {
        await __classPrivateFieldGet(this, _HttpAgent_instances, "m", _HttpAgent_rootKeyGuard).call(this);
        const id = await (identity !== undefined ? await identity : await __classPrivateFieldGet(this, _HttpAgent_identity, "f"));
        if (!id) {
            throw new IdentityInvalidError("This identity has expired due this application's security policy. Please refresh your authentication.");
        }
        const sender = (id === null || id === void 0 ? void 0 : id.getPrincipal()) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Principal"].anonymous();
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const transformedRequest = await this._transform({
            request: {
                method: 'POST',
                headers: Object.assign({
                    'Content-Type': 'application/cbor'
                }, __classPrivateFieldGet(this, _HttpAgent_credentials, "f") ? {
                    Authorization: 'Basic ' + btoa(__classPrivateFieldGet(this, _HttpAgent_credentials, "f"))
                } : {})
            },
            endpoint: "read_state" /* Endpoint.ReadState */ ,
            body: {
                request_type: "read_state" /* ReadRequestType.ReadState */ ,
                paths: fields.paths,
                sender,
                ingress_expiry: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$transforms$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Expiry"](__classPrivateFieldGet(this, _HttpAgent_maxIngressExpiryInMinutes, "f") * MINUTE_TO_MSECS)
            }
        });
        // Apply transform for identity.
        return id === null || id === void 0 ? void 0 : id.transformRequest(transformedRequest);
    }
    async readState(canisterId, fields, identity, // eslint-disable-next-line
    request) {
        var _a, _b, _c, _d;
        function getRequestId(fields) {
            for (const path of fields.paths){
                const [pathName, value] = path;
                const request_status = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bufFromBufLike"])(new TextEncoder().encode('request_status'));
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bufEquals"])(pathName, request_status)) {
                    return value;
                }
            }
        }
        const requestId = getRequestId(fields);
        await __classPrivateFieldGet(this, _HttpAgent_instances, "m", _HttpAgent_rootKeyGuard).call(this);
        const canister = typeof canisterId === 'string' ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Principal"].fromText(canisterId) : canisterId;
        const transformedRequest = request !== null && request !== void 0 ? request : await this.createReadStateRequest(fields, identity);
        const body = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$cbor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encode"])(transformedRequest.body);
        this.log.print(`fetching "/api/v2/canister/${canister}/read_state" with request:`, transformedRequest);
        // TODO - https://dfinity.atlassian.net/browse/SDK-1092
        const backoff = __classPrivateFieldGet(this, _HttpAgent_backoffStrategy, "f").call(this);
        try {
            const response = await __classPrivateFieldGet(this, _HttpAgent_instances, "m", _HttpAgent_requestAndRetry).call(this, {
                request: ()=>__classPrivateFieldGet(this, _HttpAgent_fetch, "f").call(this, '' + new URL(`/api/v2/canister/${canister.toString()}/read_state`, this.host), Object.assign(Object.assign(Object.assign({}, __classPrivateFieldGet(this, _HttpAgent_fetchOptions, "f")), transformedRequest.request), {
                        body
                    })),
                backoff,
                tries: 0
            });
            if (!response.ok) {
                throw new Error(`Server returned an error:\n` + `  Code: ${response.status} (${response.statusText})\n` + `  Body: ${await response.text()}\n`);
            }
            const decodedResponse = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$cbor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decode"])(await response.arrayBuffer());
            this.log.print('Read state response:', decodedResponse);
            const parsedTime = await this.parseTimeFromResponse(decodedResponse);
            if (parsedTime > 0) {
                this.log.print('Read state response time:', parsedTime);
                __classPrivateFieldSet(this, _HttpAgent_waterMark, parsedTime, "f");
            }
            return decodedResponse;
        } catch (error) {
            const message = `Caught exception while attempting to read state: ${(_a = error.message) !== null && _a !== void 0 ? _a : String(error)}`;
            const readStateError = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AgentReadStateError"](message, error, String(requestId), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toHex"])((_b = transformedRequest === null || transformedRequest === void 0 ? void 0 : transformedRequest.body) === null || _b === void 0 ? void 0 : _b.sender_pubkey), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toHex"])((_c = transformedRequest === null || transformedRequest === void 0 ? void 0 : transformedRequest.body) === null || _c === void 0 ? void 0 : _c.sender_sig), String((_d = transformedRequest === null || transformedRequest === void 0 ? void 0 : transformedRequest.body) === null || _d === void 0 ? void 0 : _d.content.ingress_expiry['_value']));
            this.log.error(message, readStateError);
            throw readStateError;
        }
    }
    async parseTimeFromResponse(response) {
        let tree;
        if (response.certificate) {
            const decoded = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$cbor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decode"])(response.certificate);
            if (decoded && 'tree' in decoded) {
                tree = decoded.tree;
            } else {
                throw new Error('Could not decode time from response');
            }
            const timeLookup = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$certificate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lookup_path"])([
                'time'
            ], tree);
            if (timeLookup.status !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$certificate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LookupStatus"].Found) {
                throw new Error('Time was not found in the response or was not in its expected format.');
            }
            if (!(timeLookup.value instanceof ArrayBuffer) && !ArrayBuffer.isView(timeLookup)) {
                throw new Error('Time was not found in the response or was not in its expected format.');
            }
            const date = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$leb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decodeTime"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bufFromBufLike"])(timeLookup.value));
            this.log.print('Time from response:', date);
            this.log.print('Time from response in milliseconds:', Number(date));
            return Number(date);
        } else {
            this.log.warn('No certificate found in response');
        }
        return 0;
    }
    /**
     * Allows agent to sync its time with the network. Can be called during intialization or mid-lifecycle if the device's clock has drifted away from the network time. This is necessary to set the Expiry for a request
     * @param {Principal} canisterId - Pass a canister ID if you need to sync the time with a particular replica. Uses the management canister by default
     */ async syncTime(canisterId) {
        await __classPrivateFieldGet(this, _HttpAgent_instances, "m", _HttpAgent_rootKeyGuard).call(this);
        const CanisterStatus = await __turbopack_context__.r("[project]/node_modules/@dfinity/agent/lib/esm/canisterStatus/index.js [app-ssr] (ecmascript, async loader)")(__turbopack_context__.i);
        const callTime = Date.now();
        try {
            if (!canisterId) {
                this.log.print('Syncing time with the IC. No canisterId provided, so falling back to ryjl3-tyaaa-aaaaa-aaaba-cai');
            }
            const anonymousAgent = HttpAgent.createSync({
                identity: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$auth$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AnonymousIdentity"](),
                host: this.host.toString(),
                fetch: __classPrivateFieldGet(this, _HttpAgent_fetch, "f"),
                retryTimes: 0
            });
            const status = await CanisterStatus.request({
                // Fall back with canisterId of the ICP Ledger
                canisterId: canisterId !== null && canisterId !== void 0 ? canisterId : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Principal"].from('ryjl3-tyaaa-aaaaa-aaaba-cai'),
                agent: anonymousAgent,
                paths: [
                    'time'
                ]
            });
            const replicaTime = status.get('time');
            if (replicaTime) {
                __classPrivateFieldSet(this, _HttpAgent_timeDiffMsecs, Number(replicaTime) - Number(callTime), "f");
                this.log.notify({
                    message: `Syncing time: offset of ${__classPrivateFieldGet(this, _HttpAgent_timeDiffMsecs, "f")}`,
                    level: 'info'
                });
            }
        } catch (error) {
            this.log.error('Caught exception while attempting to sync time', error);
        }
    }
    async status() {
        const headers = __classPrivateFieldGet(this, _HttpAgent_credentials, "f") ? {
            Authorization: 'Basic ' + btoa(__classPrivateFieldGet(this, _HttpAgent_credentials, "f"))
        } : {};
        this.log.print(`fetching "/api/v2/status"`);
        const backoff = __classPrivateFieldGet(this, _HttpAgent_backoffStrategy, "f").call(this);
        const response = await __classPrivateFieldGet(this, _HttpAgent_instances, "m", _HttpAgent_requestAndRetry).call(this, {
            backoff,
            request: ()=>__classPrivateFieldGet(this, _HttpAgent_fetch, "f").call(this, '' + new URL(`/api/v2/status`, this.host), Object.assign({
                    headers
                }, __classPrivateFieldGet(this, _HttpAgent_fetchOptions, "f"))),
            tries: 0
        });
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$cbor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decode"])(await response.arrayBuffer());
    }
    async fetchRootKey() {
        let result;
        // Wait for already pending promise to avoid duplicate calls
        if (__classPrivateFieldGet(this, _HttpAgent_rootKeyPromise, "f")) {
            result = await __classPrivateFieldGet(this, _HttpAgent_rootKeyPromise, "f");
        } else {
            // construct promise
            __classPrivateFieldSet(this, _HttpAgent_rootKeyPromise, new Promise((resolve, reject)=>{
                this.status().then((value)=>{
                    // Hex-encoded version of the replica root key
                    const rootKey = value.root_key;
                    this.rootKey = rootKey;
                    resolve(rootKey);
                }).catch(reject);
            }), "f");
            result = await __classPrivateFieldGet(this, _HttpAgent_rootKeyPromise, "f");
        }
        // clear rootkey promise and return result
        __classPrivateFieldSet(this, _HttpAgent_rootKeyPromise, null, "f");
        return result;
    }
    invalidateIdentity() {
        __classPrivateFieldSet(this, _HttpAgent_identity, null, "f");
    }
    replaceIdentity(identity) {
        __classPrivateFieldSet(this, _HttpAgent_identity, Promise.resolve(identity), "f");
    }
    async fetchSubnetKeys(canisterId) {
        await __classPrivateFieldGet(this, _HttpAgent_instances, "m", _HttpAgent_rootKeyGuard).call(this);
        const effectiveCanisterId = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Principal"].from(canisterId);
        const response = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$canisterStatus$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["request"])({
            canisterId: effectiveCanisterId,
            paths: [
                'subnet'
            ],
            agent: this
        });
        const subnetResponse = response.get('subnet');
        if (subnetResponse && typeof subnetResponse === 'object' && 'nodeKeys' in subnetResponse) {
            __classPrivateFieldGet(this, _HttpAgent_subnetKeys, "f").set(effectiveCanisterId.toText(), subnetResponse);
            return subnetResponse;
        }
        // If the subnet status is not returned, return undefined
        return undefined;
    }
    _transform(request) {
        let p = Promise.resolve(request);
        if (request.endpoint === "call" /* Endpoint.Call */ ) {
            for (const fn of __classPrivateFieldGet(this, _HttpAgent_updatePipeline, "f")){
                p = p.then((r)=>fn(r).then((r2)=>r2 || r));
            }
        } else {
            for (const fn of __classPrivateFieldGet(this, _HttpAgent_queryPipeline, "f")){
                p = p.then((r)=>fn(r).then((r2)=>r2 || r));
            }
        }
        return p;
    }
}
_HttpAgent_rootKeyPromise = new WeakMap(), _HttpAgent_shouldFetchRootKey = new WeakMap(), _HttpAgent_identity = new WeakMap(), _HttpAgent_fetch = new WeakMap(), _HttpAgent_fetchOptions = new WeakMap(), _HttpAgent_callOptions = new WeakMap(), _HttpAgent_timeDiffMsecs = new WeakMap(), _HttpAgent_credentials = new WeakMap(), _HttpAgent_retryTimes = new WeakMap(), _HttpAgent_backoffStrategy = new WeakMap(), _HttpAgent_maxIngressExpiryInMinutes = new WeakMap(), _HttpAgent_waterMark = new WeakMap(), _HttpAgent_queryPipeline = new WeakMap(), _HttpAgent_updatePipeline = new WeakMap(), _HttpAgent_subnetKeys = new WeakMap(), _HttpAgent_verifyQuerySignatures = new WeakMap(), _HttpAgent_verifyQueryResponse = new WeakMap(), _HttpAgent_instances = new WeakSet(), _HttpAgent_requestAndRetryQuery = async function _HttpAgent_requestAndRetryQuery(args) {
    var _a, _b;
    const { ecid, transformedRequest, body, requestId, backoff, tries } = args;
    const delay = tries === 0 ? 0 : backoff.next();
    this.log.print(`fetching "/api/v2/canister/${ecid.toString()}/query" with tries:`, {
        tries,
        backoff,
        delay
    });
    // If delay is null, the backoff strategy is exhausted due to a maximum number of retries, duration, or other reason
    if (delay === null) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AgentError"](`Timestamp failed to pass the watermark after retrying the configured ${__classPrivateFieldGet(this, _HttpAgent_retryTimes, "f")} times. We cannot guarantee the integrity of the response since it could be a replay attack.`);
    }
    if (delay > 0) {
        await new Promise((resolve)=>setTimeout(resolve, delay));
    }
    let response;
    // Make the request and retry if it throws an error
    try {
        this.log.print(`fetching "/api/v2/canister/${ecid.toString()}/query" with request:`, transformedRequest);
        const fetchResponse = await __classPrivateFieldGet(this, _HttpAgent_fetch, "f").call(this, '' + new URL(`/api/v2/canister/${ecid.toString()}/query`, this.host), Object.assign(Object.assign(Object.assign({}, __classPrivateFieldGet(this, _HttpAgent_fetchOptions, "f")), transformedRequest.request), {
            body
        }));
        if (fetchResponse.status === 200) {
            const queryResponse = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$cbor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decode"])(await fetchResponse.arrayBuffer());
            response = Object.assign(Object.assign({}, queryResponse), {
                httpDetails: {
                    ok: fetchResponse.ok,
                    status: fetchResponse.status,
                    statusText: fetchResponse.statusText,
                    headers: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$transforms$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["httpHeadersTransform"])(fetchResponse.headers)
                },
                requestId
            });
        } else {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AgentHTTPResponseError"](`Gateway returned an error:\n` + `  Code: ${fetchResponse.status} (${fetchResponse.statusText})\n` + `  Body: ${await fetchResponse.text()}\n`, {
                ok: fetchResponse.ok,
                status: fetchResponse.status,
                statusText: fetchResponse.statusText,
                headers: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$transforms$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["httpHeadersTransform"])(fetchResponse.headers)
            });
        }
    } catch (error) {
        if (tries < __classPrivateFieldGet(this, _HttpAgent_retryTimes, "f")) {
            this.log.warn(`Caught exception while attempting to make query:\n` + `  ${error}\n` + `  Retrying query.`);
            return await __classPrivateFieldGet(this, _HttpAgent_instances, "m", _HttpAgent_requestAndRetryQuery).call(this, Object.assign(Object.assign({}, args), {
                tries: tries + 1
            }));
        }
        throw error;
    }
    const timestamp = (_b = (_a = response.signatures) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.timestamp;
    // Skip watermark verification if the user has set verifyQuerySignatures to false
    if (!__classPrivateFieldGet(this, _HttpAgent_verifyQuerySignatures, "f")) {
        return response;
    }
    if (!timestamp) {
        throw new Error('Timestamp not found in query response. This suggests a malformed or malicious response.');
    }
    // Convert the timestamp to milliseconds
    const timeStampInMs = Number(BigInt(timestamp) / BigInt(1000000));
    this.log.print('watermark and timestamp', {
        waterMark: this.waterMark,
        timestamp: timeStampInMs
    });
    // If the timestamp is less than the watermark, retry the request up to the retry limit
    if (Number(this.waterMark) > timeStampInMs) {
        const error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AgentError"]('Timestamp is below the watermark. Retrying query.');
        this.log.error('Timestamp is below', error, {
            timestamp,
            waterMark: this.waterMark
        });
        if (tries < __classPrivateFieldGet(this, _HttpAgent_retryTimes, "f")) {
            return await __classPrivateFieldGet(this, _HttpAgent_instances, "m", _HttpAgent_requestAndRetryQuery).call(this, Object.assign(Object.assign({}, args), {
                tries: tries + 1
            }));
        }
        {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AgentError"](`Timestamp failed to pass the watermark after retrying the configured ${__classPrivateFieldGet(this, _HttpAgent_retryTimes, "f")} times. We cannot guarantee the integrity of the response since it could be a replay attack.`);
        }
    }
    return response;
}, _HttpAgent_requestAndRetry = async function _HttpAgent_requestAndRetry(args) {
    const { request, backoff, tries } = args;
    const delay = tries === 0 ? 0 : backoff.next();
    // If delay is null, the backoff strategy is exhausted due to a maximum number of retries, duration, or other reason
    if (delay === null) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AgentError"](`Timestamp failed to pass the watermark after retrying the configured ${__classPrivateFieldGet(this, _HttpAgent_retryTimes, "f")} times. We cannot guarantee the integrity of the response since it could be a replay attack.`);
    }
    if (delay > 0) {
        await new Promise((resolve)=>setTimeout(resolve, delay));
    }
    let response;
    try {
        response = await request();
    } catch (error) {
        if (__classPrivateFieldGet(this, _HttpAgent_retryTimes, "f") > tries) {
            this.log.warn(`Caught exception while attempting to make request:\n` + `  ${error}\n` + `  Retrying request.`);
            // Delay the request by the configured backoff strategy
            return await __classPrivateFieldGet(this, _HttpAgent_instances, "m", _HttpAgent_requestAndRetry).call(this, {
                request,
                backoff,
                tries: tries + 1
            });
        }
        throw error;
    }
    if (response.ok) {
        return response;
    }
    const responseText = await response.clone().text();
    const errorMessage = `Server returned an error:\n` + `  Code: ${response.status} (${response.statusText})\n` + `  Body: ${responseText}\n`;
    if (response.status === 404 && response.url.includes('api/v3')) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AgentHTTPResponseError"]('v3 api not supported. Fall back to v2', {
            ok: response.ok,
            status: response.status,
            statusText: response.statusText,
            headers: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$transforms$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["httpHeadersTransform"])(response.headers)
        });
    }
    if (tries < __classPrivateFieldGet(this, _HttpAgent_retryTimes, "f")) {
        return await __classPrivateFieldGet(this, _HttpAgent_instances, "m", _HttpAgent_requestAndRetry).call(this, {
            request,
            backoff,
            tries: tries + 1
        });
    }
    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AgentHTTPResponseError"](errorMessage, {
        ok: response.ok,
        status: response.status,
        statusText: response.statusText,
        headers: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$transforms$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["httpHeadersTransform"])(response.headers)
    });
}, _HttpAgent_rootKeyGuard = async function _HttpAgent_rootKeyGuard() {
    if (this.rootKey) {
        return;
    } else if (this.rootKey === null && __classPrivateFieldGet(this, _HttpAgent_shouldFetchRootKey, "f")) {
        await this.fetchRootKey();
    } else {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AgentError"](`Invalid root key detected. The root key for this agent is ${this.rootKey} and the shouldFetchRootKey value is set to ${__classPrivateFieldGet(this, _HttpAgent_shouldFetchRootKey, "f")}. The root key should only be unknown if you are in local development. Otherwise you should avoid fetching and use the default IC Root Key or the known root key of your environment.`);
    }
}; //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@dfinity/agent/lib/esm/certificate.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "Certificate": (()=>Certificate),
    "CertificateVerificationError": (()=>CertificateVerificationError),
    "LookupStatus": (()=>LookupStatus),
    "NodeType": (()=>NodeType),
    "check_canister_ranges": (()=>check_canister_ranges),
    "find_label": (()=>find_label),
    "flatten_forks": (()=>flatten_forks),
    "hashTreeToString": (()=>hashTreeToString),
    "lookupResultToBuffer": (()=>lookupResultToBuffer),
    "lookup_path": (()=>lookup_path),
    "reconstruct": (()=>reconstruct)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$cbor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/cbor.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/errors.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$request_id$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/request_id.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/utils/buffer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/principal/lib/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$bls$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/utils/bls.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$leb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/utils/leb.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/agent/index.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/agent/http/index.js [app-ssr] (ecmascript) <locals>");
var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Certificate_disableTimeVerification;
;
;
;
;
;
;
;
;
class CertificateVerificationError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AgentError"] {
    constructor(reason){
        super(`Invalid certificate: ${reason}`);
    }
}
var NodeType;
(function(NodeType) {
    NodeType[NodeType["Empty"] = 0] = "Empty";
    NodeType[NodeType["Fork"] = 1] = "Fork";
    NodeType[NodeType["Labeled"] = 2] = "Labeled";
    NodeType[NodeType["Leaf"] = 3] = "Leaf";
    NodeType[NodeType["Pruned"] = 4] = "Pruned";
})(NodeType || (NodeType = {}));
function hashTreeToString(tree) {
    const indent = (s)=>s.split('\n').map((x)=>'  ' + x).join('\n');
    function labelToString(label) {
        const decoder = new TextDecoder(undefined, {
            fatal: true
        });
        try {
            return JSON.stringify(decoder.decode(label));
        } catch (e) {
            return `data(...${label.byteLength} bytes)`;
        }
    }
    switch(tree[0]){
        case NodeType.Empty:
            return '()';
        case NodeType.Fork:
            {
                if (tree[1] instanceof Array && tree[2] instanceof ArrayBuffer) {
                    const left = hashTreeToString(tree[1]);
                    const right = hashTreeToString(tree[2]);
                    return `sub(\n left:\n${indent(left)}\n---\n right:\n${indent(right)}\n)`;
                } else {
                    throw new Error('Invalid tree structure for fork');
                }
            }
        case NodeType.Labeled:
            {
                if (tree[1] instanceof ArrayBuffer && tree[2] instanceof ArrayBuffer) {
                    const label = labelToString(tree[1]);
                    const sub = hashTreeToString(tree[2]);
                    return `label(\n label:\n${indent(label)}\n sub:\n${indent(sub)}\n)`;
                } else {
                    throw new Error('Invalid tree structure for labeled');
                }
            }
        case NodeType.Leaf:
            {
                if (!tree[1]) {
                    throw new Error('Invalid tree structure for leaf');
                } else if (Array.isArray(tree[1])) {
                    return JSON.stringify(tree[1]);
                }
                return `leaf(...${tree[1].byteLength} bytes)`;
            }
        case NodeType.Pruned:
            {
                if (!tree[1]) {
                    throw new Error('Invalid tree structure for pruned');
                } else if (Array.isArray(tree[1])) {
                    return JSON.stringify(tree[1]);
                }
                return `pruned(${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toHex"])(new Uint8Array(tree[1]))}`;
            }
        default:
            {
                return `unknown(${JSON.stringify(tree[0])})`;
            }
    }
}
function isBufferGreaterThan(a, b) {
    const a8 = new Uint8Array(a);
    const b8 = new Uint8Array(b);
    for(let i = 0; i < a8.length; i++){
        if (a8[i] > b8[i]) {
            return true;
        }
    }
    return false;
}
class Certificate {
    constructor(certificate, _rootKey, _canisterId, _blsVerify, // Default to 5 minutes
    _maxAgeInMinutes = 5, disableTimeVerification = false){
        this._rootKey = _rootKey;
        this._canisterId = _canisterId;
        this._blsVerify = _blsVerify;
        this._maxAgeInMinutes = _maxAgeInMinutes;
        _Certificate_disableTimeVerification.set(this, false);
        __classPrivateFieldSet(this, _Certificate_disableTimeVerification, disableTimeVerification, "f");
        this.cert = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$cbor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decode"])(new Uint8Array(certificate));
    }
    /**
     * Create a new instance of a certificate, automatically verifying it. Throws a
     * CertificateVerificationError if the certificate cannot be verified.
     * @constructs  Certificate
     * @param {CreateCertificateOptions} options {@link CreateCertificateOptions}
     * @param {ArrayBuffer} options.certificate The bytes of the certificate
     * @param {ArrayBuffer} options.rootKey The root key to verify against
     * @param {Principal} options.canisterId The effective or signing canister ID
     * @param {number} options.maxAgeInMinutes The maximum age of the certificate in minutes. Default is 5 minutes.
     * @throws {CertificateVerificationError}
     */ static async create(options) {
        const cert = Certificate.createUnverified(options);
        await cert.verify();
        return cert;
    }
    static createUnverified(options) {
        let blsVerify = options.blsVerify;
        if (!blsVerify) {
            blsVerify = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$bls$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["blsVerify"];
        }
        return new Certificate(options.certificate, options.rootKey, options.canisterId, blsVerify, options.maxAgeInMinutes, options.disableTimeVerification);
    }
    lookup(path) {
        // constrain the type of the result, so that empty HashTree is undefined
        return lookup_path(path, this.cert.tree);
    }
    lookup_label(label) {
        return this.lookup([
            label
        ]);
    }
    async verify() {
        const rootHash = await reconstruct(this.cert.tree);
        const derKey = await this._checkDelegationAndGetKey(this.cert.delegation);
        const sig = this.cert.signature;
        const key = extractDER(derKey);
        const msg = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["concat"])(domain_sep('ic-state-root'), rootHash);
        let sigVer = false;
        const lookupTime = lookupResultToBuffer(this.lookup([
            'time'
        ]));
        if (!lookupTime) {
            // Should never happen - time is always present in IC certificates
            throw new CertificateVerificationError('Certificate does not contain a time');
        }
        // Certificate time verification checks
        if (!__classPrivateFieldGet(this, _Certificate_disableTimeVerification, "f")) {
            const FIVE_MINUTES_IN_MSEC = 5 * 60 * 1000;
            const MAX_AGE_IN_MSEC = this._maxAgeInMinutes * 60 * 1000;
            const now = Date.now();
            const earliestCertificateTime = now - MAX_AGE_IN_MSEC;
            const fiveMinutesFromNow = now + FIVE_MINUTES_IN_MSEC;
            const certTime = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$leb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decodeTime"])(lookupTime);
            if (certTime.getTime() < earliestCertificateTime) {
                throw new CertificateVerificationError(`Certificate is signed more than ${this._maxAgeInMinutes} minutes in the past. Certificate time: ` + certTime.toISOString() + ' Current time: ' + new Date(now).toISOString());
            } else if (certTime.getTime() > fiveMinutesFromNow) {
                throw new CertificateVerificationError('Certificate is signed more than 5 minutes in the future. Certificate time: ' + certTime.toISOString() + ' Current time: ' + new Date(now).toISOString());
            }
        }
        try {
            sigVer = await this._blsVerify(new Uint8Array(key), new Uint8Array(sig), new Uint8Array(msg));
        } catch (err) {
            sigVer = false;
        }
        if (!sigVer) {
            throw new CertificateVerificationError('Signature verification failed');
        }
    }
    async _checkDelegationAndGetKey(d) {
        if (!d) {
            return this._rootKey;
        }
        const cert = await Certificate.createUnverified({
            certificate: d.certificate,
            rootKey: this._rootKey,
            canisterId: this._canisterId,
            blsVerify: this._blsVerify,
            // Do not check max age for delegation certificates
            maxAgeInMinutes: Infinity
        });
        if (cert.cert.delegation) {
            throw new CertificateVerificationError('Delegation certificates cannot be nested');
        }
        await cert.verify();
        if (this._canisterId.toString() !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["MANAGEMENT_CANISTER_ID"]) {
            const canisterInRange = check_canister_ranges({
                canisterId: this._canisterId,
                subnetId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Principal"].fromUint8Array(new Uint8Array(d.subnet_id)),
                tree: cert.cert.tree
            });
            if (!canisterInRange) {
                throw new CertificateVerificationError(`Canister ${this._canisterId} not in range of delegations for subnet 0x${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toHex"])(d.subnet_id)}`);
            }
        }
        const publicKeyLookup = lookupResultToBuffer(cert.lookup([
            'subnet',
            d.subnet_id,
            'public_key'
        ]));
        if (!publicKeyLookup) {
            throw new Error(`Could not find subnet key for subnet 0x${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toHex"])(d.subnet_id)}`);
        }
        return publicKeyLookup;
    }
}
_Certificate_disableTimeVerification = new WeakMap();
const DER_PREFIX = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fromHex"])('308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100');
const KEY_LENGTH = 96;
function extractDER(buf) {
    const expectedLength = DER_PREFIX.byteLength + KEY_LENGTH;
    if (buf.byteLength !== expectedLength) {
        throw new TypeError(`BLS DER-encoded public key must be ${expectedLength} bytes long`);
    }
    const prefix = buf.slice(0, DER_PREFIX.byteLength);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bufEquals"])(prefix, DER_PREFIX)) {
        throw new TypeError(`BLS DER-encoded public key is invalid. Expect the following prefix: ${DER_PREFIX}, but get ${prefix}`);
    }
    return buf.slice(DER_PREFIX.byteLength);
}
function lookupResultToBuffer(result) {
    if (result.status !== LookupStatus.Found) {
        return undefined;
    }
    if (result.value instanceof ArrayBuffer) {
        return result.value;
    }
    if (result.value instanceof Uint8Array) {
        return result.value.buffer;
    }
    return undefined;
}
async function reconstruct(t) {
    switch(t[0]){
        case NodeType.Empty:
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$request_id$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hash"])(domain_sep('ic-hashtree-empty'));
        case NodeType.Pruned:
            return t[1];
        case NodeType.Leaf:
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$request_id$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hash"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["concat"])(domain_sep('ic-hashtree-leaf'), t[1]));
        case NodeType.Labeled:
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$request_id$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hash"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["concat"])(domain_sep('ic-hashtree-labeled'), t[1], await reconstruct(t[2])));
        case NodeType.Fork:
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$request_id$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hash"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["concat"])(domain_sep('ic-hashtree-fork'), await reconstruct(t[1]), await reconstruct(t[2])));
        default:
            throw new Error('unreachable');
    }
}
function domain_sep(s) {
    const len = new Uint8Array([
        s.length
    ]);
    const str = new TextEncoder().encode(s);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["concat"])(len, str);
}
var LookupStatus;
(function(LookupStatus) {
    LookupStatus["Unknown"] = "unknown";
    LookupStatus["Absent"] = "absent";
    LookupStatus["Found"] = "found";
})(LookupStatus || (LookupStatus = {}));
var LabelLookupStatus;
(function(LabelLookupStatus) {
    LabelLookupStatus["Less"] = "less";
    LabelLookupStatus["Greater"] = "greater";
})(LabelLookupStatus || (LabelLookupStatus = {}));
function lookup_path(path, tree) {
    if (path.length === 0) {
        switch(tree[0]){
            case NodeType.Leaf:
                {
                    if (!tree[1]) {
                        throw new Error('Invalid tree structure for leaf');
                    }
                    if (tree[1] instanceof ArrayBuffer) {
                        return {
                            status: LookupStatus.Found,
                            value: tree[1]
                        };
                    }
                    if (tree[1] instanceof Uint8Array) {
                        return {
                            status: LookupStatus.Found,
                            value: tree[1].buffer
                        };
                    }
                    return {
                        status: LookupStatus.Found,
                        value: tree[1]
                    };
                }
            default:
                {
                    return {
                        status: LookupStatus.Found,
                        value: tree
                    };
                }
        }
    }
    const label = typeof path[0] === 'string' ? new TextEncoder().encode(path[0]) : path[0];
    const lookupResult = find_label(label, tree);
    switch(lookupResult.status){
        case LookupStatus.Found:
            {
                return lookup_path(path.slice(1), lookupResult.value);
            }
        case LabelLookupStatus.Greater:
        case LabelLookupStatus.Less:
            {
                return {
                    status: LookupStatus.Absent
                };
            }
        default:
            {
                return lookupResult;
            }
    }
}
function flatten_forks(t) {
    switch(t[0]){
        case NodeType.Empty:
            return [];
        case NodeType.Fork:
            return flatten_forks(t[1]).concat(flatten_forks(t[2]));
        default:
            return [
                t
            ];
    }
}
function find_label(label, tree) {
    switch(tree[0]){
        // if we have a labelled node, compare the node's label to the one we are
        // looking for
        case NodeType.Labeled:
            // if the label we're searching for is greater than this node's label,
            // we need to keep searching
            if (isBufferGreaterThan(label, tree[1])) {
                return {
                    status: LabelLookupStatus.Greater
                };
            }
            // if the label we're searching for is equal this node's label, we can
            // stop searching and return the found node
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bufEquals"])(label, tree[1])) {
                return {
                    status: LookupStatus.Found,
                    value: tree[2]
                };
            }
            // if the label we're searching for is not greater than or equal to this
            // node's label, then it's less than this node's label, and we can stop
            // searching because we've looked too far
            return {
                status: LabelLookupStatus.Less
            };
        // if we have a fork node, we need to search both sides, starting with the left
        case NodeType.Fork:
            // search in the left node
            const leftLookupResult = find_label(label, tree[1]);
            switch(leftLookupResult.status){
                // if the label we're searching for is greater than the left node lookup,
                // we need to search the right node
                case LabelLookupStatus.Greater:
                    {
                        const rightLookupResult = find_label(label, tree[2]);
                        // if the label we're searching for is less than the right node lookup,
                        // then we can stop searching and say that the label is provably Absent
                        if (rightLookupResult.status === LabelLookupStatus.Less) {
                            return {
                                status: LookupStatus.Absent
                            };
                        }
                        // if the label we're searching for is less than or equal to the right
                        // node lookup, then we let the caller handle it
                        return rightLookupResult;
                    }
                // if the left node returns an uncertain result, we need to search the
                // right node
                case LookupStatus.Unknown:
                    {
                        let rightLookupResult = find_label(label, tree[2]);
                        // if the label we're searching for is less than the right node lookup,
                        // then we also need to return an uncertain result
                        if (rightLookupResult.status === LabelLookupStatus.Less) {
                            return {
                                status: LookupStatus.Unknown
                            };
                        }
                        // if the label we're searching for is less than or equal to the right
                        // node lookup, then we let the caller handle it
                        return rightLookupResult;
                    }
                // if the label we're searching for is not greater than the left node
                // lookup, or the result is not uncertain, we stop searching and return
                // whatever the result of the left node lookup was, which can be either
                // Found or Absent
                default:
                    {
                        return leftLookupResult;
                    }
            }
        // if we encounter a Pruned node, we can't know for certain if the label
        // we're searching for is present or not
        case NodeType.Pruned:
            return {
                status: LookupStatus.Unknown
            };
        // if the current node is Empty, or a Leaf, we can stop searching because
        // we know for sure that the label we're searching for is not present
        default:
            return {
                status: LookupStatus.Absent
            };
    }
}
function check_canister_ranges(params) {
    const { canisterId, subnetId, tree } = params;
    const rangeLookup = lookup_path([
        'subnet',
        subnetId.toUint8Array(),
        'canister_ranges'
    ], tree);
    if (rangeLookup.status !== LookupStatus.Found || !(rangeLookup.value instanceof ArrayBuffer)) {
        throw new Error(`Could not find canister ranges for subnet ${subnetId}`);
    }
    const ranges_arr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$cbor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decode"])(rangeLookup.value);
    const ranges = ranges_arr.map((v)=>[
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Principal"].fromUint8Array(v[0]),
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Principal"].fromUint8Array(v[1])
        ]);
    const canisterInRange = ranges.some((r)=>r[0].ltEq(canisterId) && r[1].gtEq(canisterId));
    return canisterInRange;
} //# sourceMappingURL=certificate.js.map
}}),
"[project]/node_modules/@dfinity/agent/lib/esm/canisterStatus/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/** @module CanisterStatus */ __turbopack_context__.s({
    "CustomPath": (()=>CustomPath),
    "encodePath": (()=>encodePath),
    "fetchNodeKeys": (()=>fetchNodeKeys),
    "request": (()=>request)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/principal/lib/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/errors.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$certificate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/certificate.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/utils/buffer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$cbor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/cbor.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$leb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/utils/leb.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
class CustomPath {
    constructor(key, path, decodeStrategy){
        this.key = key;
        this.path = path;
        this.decodeStrategy = decodeStrategy;
    }
}
const request = async (options)=>{
    const { agent, paths } = options;
    const canisterId = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Principal"].from(options.canisterId);
    const uniquePaths = [
        ...new Set(paths)
    ];
    // Map path options to their correct formats
    const encodedPaths = uniquePaths.map((path)=>{
        return encodePath(path, canisterId);
    });
    const status = new Map();
    const promises = uniquePaths.map((path, index)=>{
        return (async ()=>{
            var _a;
            try {
                const response = await agent.readState(canisterId, {
                    paths: [
                        encodedPaths[index]
                    ]
                });
                if (agent.rootKey == null) {
                    throw new Error('Agent is missing root key');
                }
                const cert = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$certificate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Certificate"].create({
                    certificate: response.certificate,
                    rootKey: agent.rootKey,
                    canisterId: canisterId,
                    disableTimeVerification: true
                });
                const lookup = (cert, path)=>{
                    if (path === 'subnet') {
                        if (agent.rootKey == null) {
                            throw new Error('Agent is missing root key');
                        }
                        const data = fetchNodeKeys(response.certificate, canisterId, agent.rootKey);
                        return {
                            path: path,
                            data
                        };
                    } else {
                        return {
                            path: path,
                            data: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$certificate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lookupResultToBuffer"])(cert.lookup(encodePath(path, canisterId)))
                        };
                    }
                };
                // must pass in the rootKey if we have no delegation
                const { path, data } = lookup(cert, uniquePaths[index]);
                if (!data) {
                    // Typically, the cert lookup will throw
                    console.warn(`Expected to find result for path ${path}, but instead found nothing.`);
                    if (typeof path === 'string') {
                        status.set(path, null);
                    } else {
                        status.set(path.key, null);
                    }
                } else {
                    switch(path){
                        case 'time':
                            {
                                status.set(path, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$leb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decodeTime"])(data));
                                break;
                            }
                        case 'controllers':
                            {
                                status.set(path, decodeControllers(data));
                                break;
                            }
                        case 'module_hash':
                            {
                                status.set(path, decodeHex(data));
                                break;
                            }
                        case 'subnet':
                            {
                                status.set(path, data);
                                break;
                            }
                        case 'candid':
                            {
                                status.set(path, new TextDecoder().decode(data));
                                break;
                            }
                        default:
                            {
                                // Check for CustomPath signature
                                if (typeof path !== 'string' && 'key' in path && 'path' in path) {
                                    switch(path.decodeStrategy){
                                        case 'raw':
                                            status.set(path.key, data);
                                            break;
                                        case 'leb128':
                                            {
                                                status.set(path.key, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$leb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decodeLeb128"])(data));
                                                break;
                                            }
                                        case 'cbor':
                                            {
                                                status.set(path.key, decodeCbor(data));
                                                break;
                                            }
                                        case 'hex':
                                            {
                                                status.set(path.key, decodeHex(data));
                                                break;
                                            }
                                        case 'utf-8':
                                            {
                                                status.set(path.key, decodeUtf8(data));
                                            }
                                    }
                                }
                            }
                    }
                }
            } catch (error) {
                // Break on signature verification errors
                if ((_a = error === null || error === void 0 ? void 0 : error.message) === null || _a === void 0 ? void 0 : _a.includes('Invalid certificate')) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AgentError"](error.message);
                }
                if (typeof path !== 'string' && 'key' in path && 'path' in path) {
                    status.set(path.key, null);
                } else {
                    status.set(path, null);
                }
                console.group();
                console.warn(`Expected to find result for path ${path}, but instead found nothing.`);
                console.warn(error);
                console.groupEnd();
            }
        })();
    });
    // Fetch all values separately, as each option can fail
    await Promise.all(promises);
    return status;
};
const fetchNodeKeys = (certificate, canisterId, root_key)=>{
    if (!canisterId._isPrincipal) {
        throw new Error('Invalid canisterId');
    }
    const cert = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$cbor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decode"])(new Uint8Array(certificate));
    const tree = cert.tree;
    let delegation = cert.delegation;
    let subnetId;
    if (delegation && delegation.subnet_id) {
        subnetId = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Principal"].fromUint8Array(new Uint8Array(delegation.subnet_id));
    } else if (!delegation && typeof root_key !== 'undefined') {
        subnetId = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Principal"].selfAuthenticating(new Uint8Array(root_key));
        delegation = {
            subnet_id: subnetId.toUint8Array(),
            certificate: new ArrayBuffer(0)
        };
    } else {
        subnetId = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Principal"].selfAuthenticating(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Principal"].fromText('tdb26-jop6k-aogll-7ltgs-eruif-6kk7m-qpktf-gdiqx-mxtrf-vb5e6-eqe').toUint8Array());
        delegation = {
            subnet_id: subnetId.toUint8Array(),
            certificate: new ArrayBuffer(0)
        };
    }
    const canisterInRange = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$certificate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["check_canister_ranges"])({
        canisterId,
        subnetId,
        tree
    });
    if (!canisterInRange) {
        throw new Error('Canister not in range');
    }
    const subnetLookupResult = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$certificate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lookup_path"])([
        'subnet',
        delegation.subnet_id,
        'node'
    ], tree);
    if (subnetLookupResult.status !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$certificate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LookupStatus"].Found) {
        throw new Error('Node not found');
    }
    if (subnetLookupResult.value instanceof ArrayBuffer) {
        throw new Error('Invalid node tree');
    }
    const nodeForks = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$certificate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["flatten_forks"])(subnetLookupResult.value);
    const nodeKeys = new Map();
    nodeForks.forEach((fork)=>{
        const node_id = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Principal"].from(new Uint8Array(fork[1])).toText();
        const publicKeyLookupResult = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$certificate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lookup_path"])([
            'public_key'
        ], fork[2]);
        if (publicKeyLookupResult.status !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$certificate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LookupStatus"].Found) {
            throw new Error('Public key not found');
        }
        const derEncodedPublicKey = publicKeyLookupResult.value;
        if (derEncodedPublicKey.byteLength !== 44) {
            throw new Error('Invalid public key length');
        } else {
            nodeKeys.set(node_id, derEncodedPublicKey);
        }
    });
    return {
        subnetId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Principal"].fromUint8Array(new Uint8Array(delegation.subnet_id)).toText(),
        nodeKeys
    };
};
const encodePath = (path, canisterId)=>{
    const encoder = new TextEncoder();
    const encode = (arg)=>{
        return new DataView(encoder.encode(arg).buffer).buffer;
    };
    const canisterBuffer = new DataView(canisterId.toUint8Array().buffer).buffer;
    switch(path){
        case 'time':
            return [
                encode('time')
            ];
        case 'controllers':
            return [
                encode('canister'),
                canisterBuffer,
                encode('controllers')
            ];
        case 'module_hash':
            return [
                encode('canister'),
                canisterBuffer,
                encode('module_hash')
            ];
        case 'subnet':
            return [
                encode('subnet')
            ];
        case 'candid':
            return [
                encode('canister'),
                canisterBuffer,
                encode('metadata'),
                encode('candid:service')
            ];
        default:
            {
                // Check for CustomPath signature
                if ('key' in path && 'path' in path) {
                    // For simplified metadata queries
                    if (typeof path['path'] === 'string' || path['path'] instanceof ArrayBuffer) {
                        const metaPath = path.path;
                        const encoded = typeof metaPath === 'string' ? encode(metaPath) : metaPath;
                        return [
                            encode('canister'),
                            canisterBuffer,
                            encode('metadata'),
                            encoded
                        ];
                    // For non-metadata, return the provided custompath
                    } else {
                        return path['path'];
                    }
                }
            }
    }
    throw new Error(`An unexpeected error was encountered while encoding your path for canister status. Please ensure that your path, ${path} was formatted correctly.`);
};
const decodeHex = (buf)=>{
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toHex"])(buf);
};
const decodeCbor = (buf)=>{
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$cbor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decode"])(buf);
};
const decodeUtf8 = (buf)=>{
    return new TextDecoder().decode(buf);
};
// Controllers are CBOR-encoded buffers
const decodeControllers = (buf)=>{
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const controllersRaw = decodeCbor(buf);
    return controllersRaw.map((buf)=>{
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Principal"].fromUint8Array(new Uint8Array(buf));
    });
}; //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@dfinity/agent/lib/esm/agent/http/index.js [app-ssr] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/principal/lib/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/errors.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$auth$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/auth.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$cbor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/cbor.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$request_id$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/request_id.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/utils/buffer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$transforms$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/agent/http/transforms.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/agent/http/types.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/agent/http/errors.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$canisterStatus$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/canisterStatus/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$certificate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/certificate.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$expirableMap$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/utils/expirableMap.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$public_key$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/public_key.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$leb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/utils/leb.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/observable.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$polling$2f$backoff$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/polling/backoff.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/agent/http/index.js [app-ssr] (ecmascript) <locals>");
}}),
"[project]/node_modules/@dfinity/agent/lib/esm/agent/proxy.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "ProxyAgent": (()=>ProxyAgent),
    "ProxyMessageKind": (()=>ProxyMessageKind),
    "ProxyStubAgent": (()=>ProxyStubAgent)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/principal/lib/esm/index.js [app-ssr] (ecmascript)");
;
var ProxyMessageKind;
(function(ProxyMessageKind) {
    ProxyMessageKind["Error"] = "err";
    ProxyMessageKind["GetPrincipal"] = "gp";
    ProxyMessageKind["GetPrincipalResponse"] = "gpr";
    ProxyMessageKind["Query"] = "q";
    ProxyMessageKind["QueryResponse"] = "qr";
    ProxyMessageKind["Call"] = "c";
    ProxyMessageKind["CallResponse"] = "cr";
    ProxyMessageKind["ReadState"] = "rs";
    ProxyMessageKind["ReadStateResponse"] = "rsr";
    ProxyMessageKind["Status"] = "s";
    ProxyMessageKind["StatusResponse"] = "sr";
})(ProxyMessageKind || (ProxyMessageKind = {}));
class ProxyStubAgent {
    constructor(_frontend, _agent){
        this._frontend = _frontend;
        this._agent = _agent;
    }
    onmessage(msg) {
        switch(msg.type){
            case ProxyMessageKind.GetPrincipal:
                this._agent.getPrincipal().then((response)=>{
                    this._frontend({
                        id: msg.id,
                        type: ProxyMessageKind.GetPrincipalResponse,
                        response: response.toText()
                    });
                });
                break;
            case ProxyMessageKind.Query:
                this._agent.query(...msg.args).then((response)=>{
                    this._frontend({
                        id: msg.id,
                        type: ProxyMessageKind.QueryResponse,
                        response
                    });
                });
                break;
            case ProxyMessageKind.Call:
                this._agent.call(...msg.args).then((response)=>{
                    this._frontend({
                        id: msg.id,
                        type: ProxyMessageKind.CallResponse,
                        response
                    });
                });
                break;
            case ProxyMessageKind.ReadState:
                this._agent.readState(...msg.args).then((response)=>{
                    this._frontend({
                        id: msg.id,
                        type: ProxyMessageKind.ReadStateResponse,
                        response
                    });
                });
                break;
            case ProxyMessageKind.Status:
                this._agent.status().then((response)=>{
                    this._frontend({
                        id: msg.id,
                        type: ProxyMessageKind.StatusResponse,
                        response
                    });
                });
                break;
            default:
                throw new Error(`Invalid message received: ${JSON.stringify(msg)}`);
        }
    }
}
class ProxyAgent {
    constructor(_backend){
        this._backend = _backend;
        this._nextId = 0;
        this._pendingCalls = new Map();
        this.rootKey = null;
    }
    onmessage(msg) {
        const id = msg.id;
        const maybePromise = this._pendingCalls.get(id);
        if (!maybePromise) {
            throw new Error('A proxy get the same message twice...');
        }
        this._pendingCalls.delete(id);
        const [resolve, reject] = maybePromise;
        switch(msg.type){
            case ProxyMessageKind.Error:
                return reject(msg.error);
            case ProxyMessageKind.GetPrincipalResponse:
            case ProxyMessageKind.CallResponse:
            case ProxyMessageKind.QueryResponse:
            case ProxyMessageKind.ReadStateResponse:
            case ProxyMessageKind.StatusResponse:
                return resolve(msg.response);
            default:
                throw new Error(`Invalid message being sent to ProxyAgent: ${JSON.stringify(msg)}`);
        }
    }
    async getPrincipal() {
        return this._sendAndWait({
            id: this._nextId++,
            type: ProxyMessageKind.GetPrincipal
        }).then((principal)=>{
            if (typeof principal !== 'string') {
                throw new Error('Invalid principal received.');
            }
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Principal"].fromText(principal);
        });
    }
    readState(canisterId, fields) {
        return this._sendAndWait({
            id: this._nextId++,
            type: ProxyMessageKind.ReadState,
            args: [
                canisterId.toString(),
                fields
            ]
        });
    }
    call(canisterId, fields) {
        return this._sendAndWait({
            id: this._nextId++,
            type: ProxyMessageKind.Call,
            args: [
                canisterId.toString(),
                fields
            ]
        });
    }
    status() {
        return this._sendAndWait({
            id: this._nextId++,
            type: ProxyMessageKind.Status
        });
    }
    query(canisterId, fields) {
        return this._sendAndWait({
            id: this._nextId++,
            type: ProxyMessageKind.Query,
            args: [
                canisterId.toString(),
                fields
            ]
        });
    }
    async _sendAndWait(msg) {
        return new Promise((resolve, reject)=>{
            this._pendingCalls.set(msg.id, [
                resolve,
                reject
            ]);
            this._backend(msg);
        });
    }
    async fetchRootKey() {
        // Hex-encoded version of the replica root key
        const rootKey = (await this.status()).root_key;
        this.rootKey = rootKey;
        return rootKey;
    }
} //# sourceMappingURL=proxy.js.map
}}),
"[project]/node_modules/@dfinity/agent/lib/esm/agent/index.js [app-ssr] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "getDefaultAgent": (()=>getDefaultAgent)
});
;
;
;
;
function getDefaultAgent() {
    const agent = typeof window === 'undefined' ? typeof global === 'undefined' ? typeof self === 'undefined' ? undefined : self.ic.agent : global.ic.agent : window.ic.agent;
    if (!agent) {
        throw new Error('No Agent could be found.');
    }
    return agent;
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@dfinity/agent/lib/esm/agent/index.js [app-ssr] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$api$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/agent/api.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/agent/http/index.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/agent/http/errors.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$proxy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/agent/proxy.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/agent/index.js [app-ssr] (ecmascript) <locals>");
}}),
"[project]/node_modules/@dfinity/agent/lib/esm/polling/strategy.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "backoff": (()=>backoff),
    "chain": (()=>chain),
    "conditionalDelay": (()=>conditionalDelay),
    "defaultStrategy": (()=>defaultStrategy),
    "maxAttempts": (()=>maxAttempts),
    "once": (()=>once),
    "throttle": (()=>throttle),
    "timeout": (()=>timeout)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/utils/buffer.js [app-ssr] (ecmascript)");
;
const FIVE_MINUTES_IN_MSEC = 5 * 60 * 1000;
function defaultStrategy() {
    return chain(conditionalDelay(once(), 1000), backoff(1000, 1.2), timeout(FIVE_MINUTES_IN_MSEC));
}
function once() {
    let first = true;
    return async ()=>{
        if (first) {
            first = false;
            return true;
        }
        return false;
    };
}
function conditionalDelay(condition, timeInMsec) {
    return async (canisterId, requestId, status)=>{
        if (await condition(canisterId, requestId, status)) {
            return new Promise((resolve)=>setTimeout(resolve, timeInMsec));
        }
    };
}
function maxAttempts(count) {
    let attempts = count;
    return async (canisterId, requestId, status)=>{
        if (--attempts <= 0) {
            throw new Error(`Failed to retrieve a reply for request after ${count} attempts:\n` + `  Request ID: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toHex"])(requestId)}\n` + `  Request status: ${status}\n`);
        }
    };
}
function throttle(throttleInMsec) {
    return ()=>new Promise((resolve)=>setTimeout(resolve, throttleInMsec));
}
function timeout(timeInMsec) {
    const end = Date.now() + timeInMsec;
    return async (canisterId, requestId, status)=>{
        if (Date.now() > end) {
            throw new Error(`Request timed out after ${timeInMsec} msec:\n` + `  Request ID: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toHex"])(requestId)}\n` + `  Request status: ${status}\n`);
        }
    };
}
function backoff(startingThrottleInMsec, backoffFactor) {
    let currentThrottling = startingThrottleInMsec;
    return ()=>new Promise((resolve)=>setTimeout(()=>{
                currentThrottling *= backoffFactor;
                resolve();
            }, currentThrottling));
}
function chain(...strategies) {
    return async (canisterId, requestId, status)=>{
        for (const a of strategies){
            await a(canisterId, requestId, status);
        }
    };
} //# sourceMappingURL=strategy.js.map
}}),
"[project]/node_modules/@dfinity/agent/lib/esm/polling/index.js [app-ssr] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "pollForResponse": (()=>pollForResponse)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/agent/http/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$certificate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/certificate.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/utils/buffer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$polling$2f$strategy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/polling/strategy.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
/**
 * Check if an object has a property
 * @param value the object that might have the property
 * @param property the key of property we're looking for
 */ function hasProperty(value, property) {
    return Object.prototype.hasOwnProperty.call(value, property);
}
/**
 * Check if value is a signed read state request with expiry
 * @param value to check
 */ function isSignedReadStateRequestWithExpiry(value) {
    return value !== null && typeof value === 'object' && hasProperty(value, 'body') && value.body !== null && typeof value.body === 'object' && hasProperty(value.body, 'content') && value.body.content !== null && typeof value.body.content === 'object' && hasProperty(value.body.content, 'request_type') && value.body.content.request_type === "read_state" /* ReadRequestType.ReadState */  && hasProperty(value.body.content, 'ingress_expiry') && typeof value.body.content.ingress_expiry === 'object' && value.body.content.ingress_expiry !== null && hasProperty(value.body.content.ingress_expiry, 'toCBOR') && typeof value.body.content.ingress_expiry.toCBOR === 'function' && hasProperty(value.body.content.ingress_expiry, 'toHash') && typeof value.body.content.ingress_expiry.toHash === 'function';
}
async function pollForResponse(agent, canisterId, requestId, strategy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$polling$2f$strategy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["defaultStrategy"])(), request, blsVerify) {
    var _a;
    const path = [
        new TextEncoder().encode('request_status'),
        requestId
    ];
    const currentRequest = request !== null && request !== void 0 ? request : await ((_a = agent.createReadStateRequest) === null || _a === void 0 ? void 0 : _a.call(agent, {
        paths: [
            path
        ]
    }));
    const state = await agent.readState(canisterId, {
        paths: [
            path
        ]
    }, undefined, currentRequest);
    if (agent.rootKey == null) throw new Error('Agent root key not initialized before polling');
    const cert = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$certificate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Certificate"].create({
        certificate: state.certificate,
        rootKey: agent.rootKey,
        canisterId: canisterId,
        blsVerify
    });
    const maybeBuf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$certificate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lookupResultToBuffer"])(cert.lookup([
        ...path,
        new TextEncoder().encode('status')
    ]));
    let status;
    if (typeof maybeBuf === 'undefined') {
        // Missing requestId means we need to wait
        status = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["RequestStatusResponseStatus"].Unknown;
    } else {
        status = new TextDecoder().decode(maybeBuf);
    }
    switch(status){
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["RequestStatusResponseStatus"].Replied:
            {
                return {
                    reply: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$certificate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lookupResultToBuffer"])(cert.lookup([
                        ...path,
                        'reply'
                    ])),
                    certificate: cert
                };
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["RequestStatusResponseStatus"].Received:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["RequestStatusResponseStatus"].Unknown:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["RequestStatusResponseStatus"].Processing:
            // Execute the polling strategy, then retry.
            await strategy(canisterId, requestId, status);
            return pollForResponse(agent, canisterId, requestId, strategy, currentRequest, blsVerify);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["RequestStatusResponseStatus"].Rejected:
            {
                const rejectCode = new Uint8Array((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$certificate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lookupResultToBuffer"])(cert.lookup([
                    ...path,
                    'reject_code'
                ])))[0];
                const rejectMessage = new TextDecoder().decode((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$certificate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lookupResultToBuffer"])(cert.lookup([
                    ...path,
                    'reject_message'
                ])));
                throw new Error(`Call was rejected:\n` + `  Request ID: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toHex"])(requestId)}\n` + `  Reject code: ${rejectCode}\n` + `  Reject text: ${rejectMessage}\n`);
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["RequestStatusResponseStatus"].Done:
            // This is _technically_ not an error, but we still didn't see the `Replied` status so
            // we don't know the result and cannot decode it.
            throw new Error(`Call was marked as done but we never saw the reply:\n` + `  Request ID: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toHex"])(requestId)}\n`);
    }
    throw new Error('unreachable');
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@dfinity/agent/lib/esm/polling/index.js [app-ssr] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/agent/index.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$certificate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/certificate.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/utils/buffer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$polling$2f$strategy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/polling/strategy.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$polling$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/polling/index.js [app-ssr] (ecmascript) <locals>");
}}),
"[project]/node_modules/@dfinity/agent/lib/esm/polling/strategy.js [app-ssr] (ecmascript) <export * as strategy>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "strategy": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$polling$2f$strategy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$polling$2f$strategy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/polling/strategy.js [app-ssr] (ecmascript)");
}}),
"[project]/node_modules/@dfinity/agent/lib/esm/canisters/management_idl.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/*
 * This file is generated from the candid for asset management.
 * didc version: 0.4.0
 */ // eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = ({ IDL })=>{
    const bitcoin_network = IDL.Variant({
        mainnet: IDL.Null,
        testnet: IDL.Null
    });
    const bitcoin_address = IDL.Text;
    const bitcoin_get_balance_args = IDL.Record({
        network: bitcoin_network,
        address: bitcoin_address,
        min_confirmations: IDL.Opt(IDL.Nat32)
    });
    const satoshi = IDL.Nat64;
    const bitcoin_get_balance_result = satoshi;
    const bitcoin_block_height = IDL.Nat32;
    const bitcoin_get_block_headers_args = IDL.Record({
        start_height: bitcoin_block_height,
        end_height: IDL.Opt(bitcoin_block_height),
        network: bitcoin_network
    });
    const bitcoin_block_header = IDL.Vec(IDL.Nat8);
    const bitcoin_get_block_headers_result = IDL.Record({
        tip_height: bitcoin_block_height,
        block_headers: IDL.Vec(bitcoin_block_header)
    });
    const bitcoin_get_current_fee_percentiles_args = IDL.Record({
        network: bitcoin_network
    });
    const millisatoshi_per_byte = IDL.Nat64;
    const bitcoin_get_current_fee_percentiles_result = IDL.Vec(millisatoshi_per_byte);
    const bitcoin_get_utxos_args = IDL.Record({
        network: bitcoin_network,
        filter: IDL.Opt(IDL.Variant({
            page: IDL.Vec(IDL.Nat8),
            min_confirmations: IDL.Nat32
        })),
        address: bitcoin_address
    });
    const bitcoin_block_hash = IDL.Vec(IDL.Nat8);
    const outpoint = IDL.Record({
        txid: IDL.Vec(IDL.Nat8),
        vout: IDL.Nat32
    });
    const utxo = IDL.Record({
        height: IDL.Nat32,
        value: satoshi,
        outpoint: outpoint
    });
    const bitcoin_get_utxos_result = IDL.Record({
        next_page: IDL.Opt(IDL.Vec(IDL.Nat8)),
        tip_height: bitcoin_block_height,
        tip_block_hash: bitcoin_block_hash,
        utxos: IDL.Vec(utxo)
    });
    const bitcoin_send_transaction_args = IDL.Record({
        transaction: IDL.Vec(IDL.Nat8),
        network: bitcoin_network
    });
    const canister_id = IDL.Principal;
    const canister_info_args = IDL.Record({
        canister_id: canister_id,
        num_requested_changes: IDL.Opt(IDL.Nat64)
    });
    const change_origin = IDL.Variant({
        from_user: IDL.Record({
            user_id: IDL.Principal
        }),
        from_canister: IDL.Record({
            canister_version: IDL.Opt(IDL.Nat64),
            canister_id: IDL.Principal
        })
    });
    const snapshot_id = IDL.Vec(IDL.Nat8);
    const change_details = IDL.Variant({
        creation: IDL.Record({
            controllers: IDL.Vec(IDL.Principal)
        }),
        code_deployment: IDL.Record({
            mode: IDL.Variant({
                reinstall: IDL.Null,
                upgrade: IDL.Null,
                install: IDL.Null
            }),
            module_hash: IDL.Vec(IDL.Nat8)
        }),
        load_snapshot: IDL.Record({
            canister_version: IDL.Nat64,
            taken_at_timestamp: IDL.Nat64,
            snapshot_id: snapshot_id
        }),
        controllers_change: IDL.Record({
            controllers: IDL.Vec(IDL.Principal)
        }),
        code_uninstall: IDL.Null
    });
    const change = IDL.Record({
        timestamp_nanos: IDL.Nat64,
        canister_version: IDL.Nat64,
        origin: change_origin,
        details: change_details
    });
    const canister_info_result = IDL.Record({
        controllers: IDL.Vec(IDL.Principal),
        module_hash: IDL.Opt(IDL.Vec(IDL.Nat8)),
        recent_changes: IDL.Vec(change),
        total_num_changes: IDL.Nat64
    });
    const canister_status_args = IDL.Record({
        canister_id: canister_id
    });
    const log_visibility = IDL.Variant({
        controllers: IDL.Null,
        public: IDL.Null,
        allowed_viewers: IDL.Vec(IDL.Principal)
    });
    const definite_canister_settings = IDL.Record({
        freezing_threshold: IDL.Nat,
        controllers: IDL.Vec(IDL.Principal),
        reserved_cycles_limit: IDL.Nat,
        log_visibility: log_visibility,
        wasm_memory_limit: IDL.Nat,
        memory_allocation: IDL.Nat,
        compute_allocation: IDL.Nat
    });
    const canister_status_result = IDL.Record({
        status: IDL.Variant({
            stopped: IDL.Null,
            stopping: IDL.Null,
            running: IDL.Null
        }),
        memory_size: IDL.Nat,
        cycles: IDL.Nat,
        settings: definite_canister_settings,
        query_stats: IDL.Record({
            response_payload_bytes_total: IDL.Nat,
            num_instructions_total: IDL.Nat,
            num_calls_total: IDL.Nat,
            request_payload_bytes_total: IDL.Nat
        }),
        idle_cycles_burned_per_day: IDL.Nat,
        module_hash: IDL.Opt(IDL.Vec(IDL.Nat8)),
        reserved_cycles: IDL.Nat
    });
    const clear_chunk_store_args = IDL.Record({
        canister_id: canister_id
    });
    const canister_settings = IDL.Record({
        freezing_threshold: IDL.Opt(IDL.Nat),
        controllers: IDL.Opt(IDL.Vec(IDL.Principal)),
        reserved_cycles_limit: IDL.Opt(IDL.Nat),
        log_visibility: IDL.Opt(log_visibility),
        wasm_memory_limit: IDL.Opt(IDL.Nat),
        memory_allocation: IDL.Opt(IDL.Nat),
        compute_allocation: IDL.Opt(IDL.Nat)
    });
    const create_canister_args = IDL.Record({
        settings: IDL.Opt(canister_settings),
        sender_canister_version: IDL.Opt(IDL.Nat64)
    });
    const create_canister_result = IDL.Record({
        canister_id: canister_id
    });
    const delete_canister_args = IDL.Record({
        canister_id: canister_id
    });
    const delete_canister_snapshot_args = IDL.Record({
        canister_id: canister_id,
        snapshot_id: snapshot_id
    });
    const deposit_cycles_args = IDL.Record({
        canister_id: canister_id
    });
    const ecdsa_curve = IDL.Variant({
        secp256k1: IDL.Null
    });
    const ecdsa_public_key_args = IDL.Record({
        key_id: IDL.Record({
            name: IDL.Text,
            curve: ecdsa_curve
        }),
        canister_id: IDL.Opt(canister_id),
        derivation_path: IDL.Vec(IDL.Vec(IDL.Nat8))
    });
    const ecdsa_public_key_result = IDL.Record({
        public_key: IDL.Vec(IDL.Nat8),
        chain_code: IDL.Vec(IDL.Nat8)
    });
    const fetch_canister_logs_args = IDL.Record({
        canister_id: canister_id
    });
    const canister_log_record = IDL.Record({
        idx: IDL.Nat64,
        timestamp_nanos: IDL.Nat64,
        content: IDL.Vec(IDL.Nat8)
    });
    const fetch_canister_logs_result = IDL.Record({
        canister_log_records: IDL.Vec(canister_log_record)
    });
    const http_header = IDL.Record({
        value: IDL.Text,
        name: IDL.Text
    });
    const http_request_result = IDL.Record({
        status: IDL.Nat,
        body: IDL.Vec(IDL.Nat8),
        headers: IDL.Vec(http_header)
    });
    const http_request_args = IDL.Record({
        url: IDL.Text,
        method: IDL.Variant({
            get: IDL.Null,
            head: IDL.Null,
            post: IDL.Null
        }),
        max_response_bytes: IDL.Opt(IDL.Nat64),
        body: IDL.Opt(IDL.Vec(IDL.Nat8)),
        transform: IDL.Opt(IDL.Record({
            function: IDL.Func([
                IDL.Record({
                    context: IDL.Vec(IDL.Nat8),
                    response: http_request_result
                })
            ], [
                http_request_result
            ], [
                'query'
            ]),
            context: IDL.Vec(IDL.Nat8)
        })),
        headers: IDL.Vec(http_header)
    });
    const canister_install_mode = IDL.Variant({
        reinstall: IDL.Null,
        upgrade: IDL.Opt(IDL.Record({
            wasm_memory_persistence: IDL.Opt(IDL.Variant({
                keep: IDL.Null,
                replace: IDL.Null
            })),
            skip_pre_upgrade: IDL.Opt(IDL.Bool)
        })),
        install: IDL.Null
    });
    const chunk_hash = IDL.Record({
        hash: IDL.Vec(IDL.Nat8)
    });
    const install_chunked_code_args = IDL.Record({
        arg: IDL.Vec(IDL.Nat8),
        wasm_module_hash: IDL.Vec(IDL.Nat8),
        mode: canister_install_mode,
        chunk_hashes_list: IDL.Vec(chunk_hash),
        target_canister: canister_id,
        store_canister: IDL.Opt(canister_id),
        sender_canister_version: IDL.Opt(IDL.Nat64)
    });
    const wasm_module = IDL.Vec(IDL.Nat8);
    const install_code_args = IDL.Record({
        arg: IDL.Vec(IDL.Nat8),
        wasm_module: wasm_module,
        mode: canister_install_mode,
        canister_id: canister_id,
        sender_canister_version: IDL.Opt(IDL.Nat64)
    });
    const list_canister_snapshots_args = IDL.Record({
        canister_id: canister_id
    });
    const snapshot = IDL.Record({
        id: snapshot_id,
        total_size: IDL.Nat64,
        taken_at_timestamp: IDL.Nat64
    });
    const list_canister_snapshots_result = IDL.Vec(snapshot);
    const load_canister_snapshot_args = IDL.Record({
        canister_id: canister_id,
        sender_canister_version: IDL.Opt(IDL.Nat64),
        snapshot_id: snapshot_id
    });
    const node_metrics_history_args = IDL.Record({
        start_at_timestamp_nanos: IDL.Nat64,
        subnet_id: IDL.Principal
    });
    const node_metrics = IDL.Record({
        num_block_failures_total: IDL.Nat64,
        node_id: IDL.Principal,
        num_blocks_proposed_total: IDL.Nat64
    });
    const node_metrics_history_result = IDL.Vec(IDL.Record({
        timestamp_nanos: IDL.Nat64,
        node_metrics: IDL.Vec(node_metrics)
    }));
    const provisional_create_canister_with_cycles_args = IDL.Record({
        settings: IDL.Opt(canister_settings),
        specified_id: IDL.Opt(canister_id),
        amount: IDL.Opt(IDL.Nat),
        sender_canister_version: IDL.Opt(IDL.Nat64)
    });
    const provisional_create_canister_with_cycles_result = IDL.Record({
        canister_id: canister_id
    });
    const provisional_top_up_canister_args = IDL.Record({
        canister_id: canister_id,
        amount: IDL.Nat
    });
    const raw_rand_result = IDL.Vec(IDL.Nat8);
    const schnorr_algorithm = IDL.Variant({
        ed25519: IDL.Null,
        bip340secp256k1: IDL.Null
    });
    const schnorr_public_key_args = IDL.Record({
        key_id: IDL.Record({
            algorithm: schnorr_algorithm,
            name: IDL.Text
        }),
        canister_id: IDL.Opt(canister_id),
        derivation_path: IDL.Vec(IDL.Vec(IDL.Nat8))
    });
    const schnorr_public_key_result = IDL.Record({
        public_key: IDL.Vec(IDL.Nat8),
        chain_code: IDL.Vec(IDL.Nat8)
    });
    const sign_with_ecdsa_args = IDL.Record({
        key_id: IDL.Record({
            name: IDL.Text,
            curve: ecdsa_curve
        }),
        derivation_path: IDL.Vec(IDL.Vec(IDL.Nat8)),
        message_hash: IDL.Vec(IDL.Nat8)
    });
    const sign_with_ecdsa_result = IDL.Record({
        signature: IDL.Vec(IDL.Nat8)
    });
    const schnorr_aux = IDL.Variant({
        bip341: IDL.Record({
            merkle_root_hash: IDL.Vec(IDL.Nat8)
        })
    });
    const sign_with_schnorr_args = IDL.Record({
        aux: IDL.Opt(schnorr_aux),
        key_id: IDL.Record({
            algorithm: schnorr_algorithm,
            name: IDL.Text
        }),
        derivation_path: IDL.Vec(IDL.Vec(IDL.Nat8)),
        message: IDL.Vec(IDL.Nat8)
    });
    const sign_with_schnorr_result = IDL.Record({
        signature: IDL.Vec(IDL.Nat8)
    });
    const start_canister_args = IDL.Record({
        canister_id: canister_id
    });
    const stop_canister_args = IDL.Record({
        canister_id: canister_id
    });
    const stored_chunks_args = IDL.Record({
        canister_id: canister_id
    });
    const stored_chunks_result = IDL.Vec(chunk_hash);
    const subnet_info_args = IDL.Record({
        subnet_id: IDL.Principal
    });
    const subnet_info_result = IDL.Record({
        replica_version: IDL.Text
    });
    const take_canister_snapshot_args = IDL.Record({
        replace_snapshot: IDL.Opt(snapshot_id),
        canister_id: canister_id
    });
    const take_canister_snapshot_result = snapshot;
    const uninstall_code_args = IDL.Record({
        canister_id: canister_id,
        sender_canister_version: IDL.Opt(IDL.Nat64)
    });
    const update_settings_args = IDL.Record({
        canister_id: IDL.Principal,
        settings: canister_settings,
        sender_canister_version: IDL.Opt(IDL.Nat64)
    });
    const upload_chunk_args = IDL.Record({
        chunk: IDL.Vec(IDL.Nat8),
        canister_id: IDL.Principal
    });
    const upload_chunk_result = chunk_hash;
    return IDL.Service({
        bitcoin_get_balance: IDL.Func([
            bitcoin_get_balance_args
        ], [
            bitcoin_get_balance_result
        ], []),
        bitcoin_get_block_headers: IDL.Func([
            bitcoin_get_block_headers_args
        ], [
            bitcoin_get_block_headers_result
        ], []),
        bitcoin_get_current_fee_percentiles: IDL.Func([
            bitcoin_get_current_fee_percentiles_args
        ], [
            bitcoin_get_current_fee_percentiles_result
        ], []),
        bitcoin_get_utxos: IDL.Func([
            bitcoin_get_utxos_args
        ], [
            bitcoin_get_utxos_result
        ], []),
        bitcoin_send_transaction: IDL.Func([
            bitcoin_send_transaction_args
        ], [], []),
        canister_info: IDL.Func([
            canister_info_args
        ], [
            canister_info_result
        ], []),
        canister_status: IDL.Func([
            canister_status_args
        ], [
            canister_status_result
        ], []),
        clear_chunk_store: IDL.Func([
            clear_chunk_store_args
        ], [], []),
        create_canister: IDL.Func([
            create_canister_args
        ], [
            create_canister_result
        ], []),
        delete_canister: IDL.Func([
            delete_canister_args
        ], [], []),
        delete_canister_snapshot: IDL.Func([
            delete_canister_snapshot_args
        ], [], []),
        deposit_cycles: IDL.Func([
            deposit_cycles_args
        ], [], []),
        ecdsa_public_key: IDL.Func([
            ecdsa_public_key_args
        ], [
            ecdsa_public_key_result
        ], []),
        fetch_canister_logs: IDL.Func([
            fetch_canister_logs_args
        ], [
            fetch_canister_logs_result
        ], [
            'query'
        ]),
        http_request: IDL.Func([
            http_request_args
        ], [
            http_request_result
        ], []),
        install_chunked_code: IDL.Func([
            install_chunked_code_args
        ], [], []),
        install_code: IDL.Func([
            install_code_args
        ], [], []),
        list_canister_snapshots: IDL.Func([
            list_canister_snapshots_args
        ], [
            list_canister_snapshots_result
        ], []),
        load_canister_snapshot: IDL.Func([
            load_canister_snapshot_args
        ], [], []),
        node_metrics_history: IDL.Func([
            node_metrics_history_args
        ], [
            node_metrics_history_result
        ], []),
        provisional_create_canister_with_cycles: IDL.Func([
            provisional_create_canister_with_cycles_args
        ], [
            provisional_create_canister_with_cycles_result
        ], []),
        provisional_top_up_canister: IDL.Func([
            provisional_top_up_canister_args
        ], [], []),
        raw_rand: IDL.Func([], [
            raw_rand_result
        ], []),
        schnorr_public_key: IDL.Func([
            schnorr_public_key_args
        ], [
            schnorr_public_key_result
        ], []),
        sign_with_ecdsa: IDL.Func([
            sign_with_ecdsa_args
        ], [
            sign_with_ecdsa_result
        ], []),
        sign_with_schnorr: IDL.Func([
            sign_with_schnorr_args
        ], [
            sign_with_schnorr_result
        ], []),
        start_canister: IDL.Func([
            start_canister_args
        ], [], []),
        stop_canister: IDL.Func([
            stop_canister_args
        ], [], []),
        stored_chunks: IDL.Func([
            stored_chunks_args
        ], [
            stored_chunks_result
        ], []),
        subnet_info: IDL.Func([
            subnet_info_args
        ], [
            subnet_info_result
        ], []),
        take_canister_snapshot: IDL.Func([
            take_canister_snapshot_args
        ], [
            take_canister_snapshot_result
        ], []),
        uninstall_code: IDL.Func([
            uninstall_code_args
        ], [], []),
        update_settings: IDL.Func([
            update_settings_args
        ], [], []),
        upload_chunk: IDL.Func([
            upload_chunk_args
        ], [
            upload_chunk_result
        ], [])
    });
};
 //# sourceMappingURL=management_idl.js.map
}}),
"[project]/node_modules/@dfinity/agent/lib/esm/actor.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "ACTOR_METHOD_WITH_CERTIFICATE": (()=>ACTOR_METHOD_WITH_CERTIFICATE),
    "ACTOR_METHOD_WITH_HTTP_DETAILS": (()=>ACTOR_METHOD_WITH_HTTP_DETAILS),
    "Actor": (()=>Actor),
    "ActorCallError": (()=>ActorCallError),
    "AdvancedActor": (()=>AdvancedActor),
    "QueryCallRejectedError": (()=>QueryCallRejectedError),
    "UpdateCallRejectedError": (()=>UpdateCallRejectedError),
    "getManagementCanister": (()=>getManagementCanister)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/buffer/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/agent/index.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/agent/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$api$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/agent/api.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/errors.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$candid$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/candid/lib/esm/index.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$candid$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/candid/lib/esm/utils/buffer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$candid$2f$lib$2f$esm$2f$idl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__IDL$3e$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/candid/lib/esm/idl.js [app-ssr] (ecmascript) <export * as IDL>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$polling$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/polling/index.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$polling$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/polling/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$polling$2f$strategy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__strategy$3e$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/polling/strategy.js [app-ssr] (ecmascript) <export * as strategy>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/principal/lib/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/utils/buffer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$certificate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/certificate.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$canisters$2f$management_idl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/canisters/management_idl.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
class ActorCallError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AgentError"] {
    constructor(canisterId, methodName, type, props){
        super([
            `Call failed:`,
            `  Canister: ${canisterId.toText()}`,
            `  Method: ${methodName} (${type})`,
            ...Object.getOwnPropertyNames(props).map((n)=>`  "${n}": ${JSON.stringify(props[n])}`)
        ].join('\n'));
        this.canisterId = canisterId;
        this.methodName = methodName;
        this.type = type;
        this.props = props;
    }
}
class QueryCallRejectedError extends ActorCallError {
    constructor(canisterId, methodName, result){
        var _a;
        super(canisterId, methodName, 'query', {
            Status: result.status,
            Code: (_a = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$api$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ReplicaRejectCode"][result.reject_code]) !== null && _a !== void 0 ? _a : `Unknown Code "${result.reject_code}"`,
            Message: result.reject_message
        });
        this.result = result;
    }
}
class UpdateCallRejectedError extends ActorCallError {
    constructor(canisterId, methodName, requestId, response, reject_code, reject_message, error_code){
        super(canisterId, methodName, 'update', Object.assign({
            'Request ID': (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toHex"])(requestId)
        }, response.body ? Object.assign(Object.assign({}, error_code ? {
            'Error code': error_code
        } : {}), {
            'Reject code': String(reject_code),
            'Reject message': reject_message
        }) : {
            'HTTP status code': response.status.toString(),
            'HTTP status text': response.statusText
        }));
        this.requestId = requestId;
        this.response = response;
        this.reject_code = reject_code;
        this.reject_message = reject_message;
        this.error_code = error_code;
    }
}
const metadataSymbol = Symbol.for('ic-agent-metadata');
class Actor {
    constructor(metadata){
        this[metadataSymbol] = Object.freeze(metadata);
    }
    /**
     * Get the Agent class this Actor would call, or undefined if the Actor would use
     * the default agent (global.ic.agent).
     * @param actor The actor to get the agent of.
     */ static agentOf(actor) {
        return actor[metadataSymbol].config.agent;
    }
    /**
     * Get the interface of an actor, in the form of an instance of a Service.
     * @param actor The actor to get the interface of.
     */ static interfaceOf(actor) {
        return actor[metadataSymbol].service;
    }
    static canisterIdOf(actor) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Principal"].from(actor[metadataSymbol].config.canisterId);
    }
    static async install(fields, config) {
        const mode = fields.mode === undefined ? {
            install: null
        } : fields.mode;
        // Need to transform the arg into a number array.
        const arg = fields.arg ? [
            ...new Uint8Array(fields.arg)
        ] : [];
        // Same for module.
        const wasmModule = [
            ...new Uint8Array(fields.module)
        ];
        const canisterId = typeof config.canisterId === 'string' ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Principal"].fromText(config.canisterId) : config.canisterId;
        await getManagementCanister(config).install_code({
            mode,
            arg,
            wasm_module: wasmModule,
            canister_id: canisterId,
            sender_canister_version: []
        });
    }
    static async createCanister(config, settings) {
        function settingsToCanisterSettings(settings) {
            return [
                {
                    controllers: settings.controllers ? [
                        settings.controllers
                    ] : [],
                    compute_allocation: settings.compute_allocation ? [
                        settings.compute_allocation
                    ] : [],
                    freezing_threshold: settings.freezing_threshold ? [
                        settings.freezing_threshold
                    ] : [],
                    memory_allocation: settings.memory_allocation ? [
                        settings.memory_allocation
                    ] : [],
                    reserved_cycles_limit: [],
                    log_visibility: [],
                    wasm_memory_limit: []
                }
            ];
        }
        const { canister_id: canisterId } = await getManagementCanister(config || {}).provisional_create_canister_with_cycles({
            amount: [],
            settings: settingsToCanisterSettings(settings || {}),
            specified_id: [],
            sender_canister_version: []
        });
        return canisterId;
    }
    static async createAndInstallCanister(interfaceFactory, fields, config) {
        const canisterId = await this.createCanister(config);
        await this.install(Object.assign({}, fields), Object.assign(Object.assign({}, config), {
            canisterId
        }));
        return this.createActor(interfaceFactory, Object.assign(Object.assign({}, config), {
            canisterId
        }));
    }
    static createActorClass(interfaceFactory, options) {
        const service = interfaceFactory({
            IDL: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$candid$2f$lib$2f$esm$2f$idl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__IDL$3e$__["IDL"]
        });
        class CanisterActor extends Actor {
            constructor(config){
                if (!config.canisterId) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AgentError"](`Canister ID is required, but received ${typeof config.canisterId} instead. If you are using automatically generated declarations, this may be because your application is not setting the canister ID in process.env correctly.`);
                const canisterId = typeof config.canisterId === 'string' ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Principal"].fromText(config.canisterId) : config.canisterId;
                super({
                    config: Object.assign(Object.assign(Object.assign({}, DEFAULT_ACTOR_CONFIG), config), {
                        canisterId
                    }),
                    service
                });
                for (const [methodName, func] of service._fields){
                    if (options === null || options === void 0 ? void 0 : options.httpDetails) {
                        func.annotations.push(ACTOR_METHOD_WITH_HTTP_DETAILS);
                    }
                    if (options === null || options === void 0 ? void 0 : options.certificate) {
                        func.annotations.push(ACTOR_METHOD_WITH_CERTIFICATE);
                    }
                    this[methodName] = _createActorMethod(this, methodName, func, config.blsVerify);
                }
            }
        }
        return CanisterActor;
    }
    static createActor(interfaceFactory, configuration) {
        if (!configuration.canisterId) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AgentError"](`Canister ID is required, but received ${typeof configuration.canisterId} instead. If you are using automatically generated declarations, this may be because your application is not setting the canister ID in process.env correctly.`);
        }
        return new (this.createActorClass(interfaceFactory))(configuration);
    }
    /**
     * Returns an actor with methods that return the http response details along with the result
     * @param interfaceFactory - the interface factory for the actor
     * @param configuration - the configuration for the actor
     * @deprecated - use createActor with actorClassOptions instead
     */ static createActorWithHttpDetails(interfaceFactory, configuration) {
        return new (this.createActorClass(interfaceFactory, {
            httpDetails: true
        }))(configuration);
    }
    /**
     * Returns an actor with methods that return the http response details along with the result
     * @param interfaceFactory - the interface factory for the actor
     * @param configuration - the configuration for the actor
     * @param actorClassOptions - options for the actor class extended details to return with the result
     */ static createActorWithExtendedDetails(interfaceFactory, configuration, actorClassOptions = {
        httpDetails: true,
        certificate: true
    }) {
        return new (this.createActorClass(interfaceFactory, actorClassOptions))(configuration);
    }
}
// IDL functions can have multiple return values, so decoding always
// produces an array. Ensure that functions with single or zero return
// values behave as expected.
function decodeReturnValue(types, msg) {
    const returnValues = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$candid$2f$lib$2f$esm$2f$idl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__IDL$3e$__["IDL"].decode(types, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Buffer"].from(msg));
    switch(returnValues.length){
        case 0:
            return undefined;
        case 1:
            return returnValues[0];
        default:
            return returnValues;
    }
}
const DEFAULT_ACTOR_CONFIG = {
    pollingStrategyFactory: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$polling$2f$strategy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__strategy$3e$__["strategy"].defaultStrategy
};
const ACTOR_METHOD_WITH_HTTP_DETAILS = 'http-details';
const ACTOR_METHOD_WITH_CERTIFICATE = 'certificate';
function _createActorMethod(actor, methodName, func, blsVerify) {
    let caller;
    if (func.annotations.includes('query') || func.annotations.includes('composite_query')) {
        caller = async (options, ...args)=>{
            var _a, _b;
            // First, if there's a config transformation, call it.
            options = Object.assign(Object.assign({}, options), (_b = (_a = actor[metadataSymbol].config).queryTransform) === null || _b === void 0 ? void 0 : _b.call(_a, methodName, args, Object.assign(Object.assign({}, actor[metadataSymbol].config), options)));
            const agent = options.agent || actor[metadataSymbol].config.agent || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getDefaultAgent"])();
            const cid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Principal"].from(options.canisterId || actor[metadataSymbol].config.canisterId);
            const arg = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$candid$2f$lib$2f$esm$2f$idl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__IDL$3e$__["IDL"].encode(func.argTypes, args);
            const result = await agent.query(cid, {
                methodName,
                arg,
                effectiveCanisterId: options.effectiveCanisterId
            });
            const httpDetails = Object.assign(Object.assign({}, result.httpDetails), {
                requestDetails: result.requestDetails
            });
            switch(result.status){
                case "rejected" /* QueryResponseStatus.Rejected */ :
                    throw new QueryCallRejectedError(cid, methodName, result);
                case "replied" /* QueryResponseStatus.Replied */ :
                    return func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS) ? {
                        httpDetails,
                        result: decodeReturnValue(func.retTypes, result.reply.arg)
                    } : decodeReturnValue(func.retTypes, result.reply.arg);
            }
        };
    } else {
        caller = async (options, ...args)=>{
            var _a, _b;
            // First, if there's a config transformation, call it.
            options = Object.assign(Object.assign({}, options), (_b = (_a = actor[metadataSymbol].config).callTransform) === null || _b === void 0 ? void 0 : _b.call(_a, methodName, args, Object.assign(Object.assign({}, actor[metadataSymbol].config), options)));
            const agent = options.agent || actor[metadataSymbol].config.agent || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getDefaultAgent"])();
            const { canisterId, effectiveCanisterId, pollingStrategyFactory } = Object.assign(Object.assign(Object.assign({}, DEFAULT_ACTOR_CONFIG), actor[metadataSymbol].config), options);
            const cid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Principal"].from(canisterId);
            const ecid = effectiveCanisterId !== undefined ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Principal"].from(effectiveCanisterId) : cid;
            const arg = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$candid$2f$lib$2f$esm$2f$idl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__IDL$3e$__["IDL"].encode(func.argTypes, args);
            const { requestId, response, requestDetails } = await agent.call(cid, {
                methodName,
                arg,
                effectiveCanisterId: ecid
            });
            let reply;
            let certificate;
            if (response.body && response.body.certificate) {
                if (agent.rootKey == null) {
                    throw new Error('Agent is missing root key');
                }
                const cert = response.body.certificate;
                certificate = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$certificate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Certificate"].create({
                    certificate: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$candid$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bufFromBufLike"])(cert),
                    rootKey: agent.rootKey,
                    canisterId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Principal"].from(canisterId),
                    blsVerify
                });
                const path = [
                    new TextEncoder().encode('request_status'),
                    requestId
                ];
                const status = new TextDecoder().decode((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$certificate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lookupResultToBuffer"])(certificate.lookup([
                    ...path,
                    'status'
                ])));
                switch(status){
                    case 'replied':
                        reply = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$certificate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lookupResultToBuffer"])(certificate.lookup([
                            ...path,
                            'reply'
                        ]));
                        break;
                    case 'rejected':
                        {
                            // Find rejection details in the certificate
                            const rejectCode = new Uint8Array((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$certificate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lookupResultToBuffer"])(certificate.lookup([
                                ...path,
                                'reject_code'
                            ])))[0];
                            const rejectMessage = new TextDecoder().decode((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$certificate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lookupResultToBuffer"])(certificate.lookup([
                                ...path,
                                'reject_message'
                            ])));
                            const error_code_buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$certificate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lookupResultToBuffer"])(certificate.lookup([
                                ...path,
                                'error_code'
                            ]));
                            const error_code = error_code_buf ? new TextDecoder().decode(error_code_buf) : undefined;
                            throw new UpdateCallRejectedError(cid, methodName, requestId, response, rejectCode, rejectMessage, error_code);
                        }
                }
            } else if (response.body && 'reject_message' in response.body) {
                // handle v2 response errors by throwing an UpdateCallRejectedError object
                const { reject_code, reject_message, error_code } = response.body;
                throw new UpdateCallRejectedError(cid, methodName, requestId, response, reject_code, reject_message, error_code);
            }
            // Fall back to polling if we receive an Accepted response code
            if (response.status === 202) {
                const pollStrategy = pollingStrategyFactory();
                // Contains the certificate and the reply from the boundary node
                const response = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$polling$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["pollForResponse"])(agent, ecid, requestId, pollStrategy, blsVerify);
                certificate = response.certificate;
                reply = response.reply;
            }
            const shouldIncludeHttpDetails = func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS);
            const shouldIncludeCertificate = func.annotations.includes(ACTOR_METHOD_WITH_CERTIFICATE);
            const httpDetails = Object.assign(Object.assign({}, response), {
                requestDetails
            });
            if (reply !== undefined) {
                if (shouldIncludeHttpDetails && shouldIncludeCertificate) {
                    return {
                        httpDetails,
                        certificate,
                        result: decodeReturnValue(func.retTypes, reply)
                    };
                } else if (shouldIncludeCertificate) {
                    return {
                        certificate,
                        result: decodeReturnValue(func.retTypes, reply)
                    };
                } else if (shouldIncludeHttpDetails) {
                    return {
                        httpDetails,
                        result: decodeReturnValue(func.retTypes, reply)
                    };
                }
                return decodeReturnValue(func.retTypes, reply);
            } else if (func.retTypes.length === 0) {
                return shouldIncludeHttpDetails ? {
                    httpDetails: response,
                    result: undefined
                } : undefined;
            } else {
                throw new Error(`Call was returned undefined, but type [${func.retTypes.join(',')}].`);
            }
        };
    }
    const handler = (...args)=>caller({}, ...args);
    handler.withOptions = (options)=>(...args)=>caller(options, ...args);
    return handler;
}
function getManagementCanister(config) {
    function transform(methodName, args) {
        if (config.effectiveCanisterId) {
            return {
                effectiveCanisterId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Principal"].from(config.effectiveCanisterId)
            };
        }
        const first = args[0];
        let effectiveCanisterId = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Principal"].fromHex('');
        if (first && typeof first === 'object' && first.target_canister && methodName === "install_chunked_code") {
            effectiveCanisterId = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Principal"].from(first.target_canister);
        }
        if (first && typeof first === 'object' && first.canister_id) {
            effectiveCanisterId = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Principal"].from(first.canister_id);
        }
        return {
            effectiveCanisterId
        };
    }
    return Actor.createActor(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$canisters$2f$management_idl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"], Object.assign(Object.assign(Object.assign({}, config), {
        canisterId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Principal"].fromHex('')
    }), {
        callTransform: transform,
        queryTransform: transform
    }));
}
class AdvancedActor extends Actor {
    constructor(metadata){
        super(metadata);
    }
} //# sourceMappingURL=actor.js.map
}}),
"[project]/node_modules/@dfinity/agent/lib/esm/canisters/asset_idl.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * This file is generated from the candid for asset management.
 */ // eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
const __TURBOPACK__default__export__ = ({ IDL })=>{
    return IDL.Service({
        retrieve: IDL.Func([
            IDL.Text
        ], [
            IDL.Vec(IDL.Nat8)
        ], [
            'query'
        ]),
        store: IDL.Func([
            IDL.Text,
            IDL.Vec(IDL.Nat8)
        ], [], [])
    });
};
 //# sourceMappingURL=asset_idl.js.map
}}),
"[project]/node_modules/@dfinity/agent/lib/esm/canisters/asset.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createAssetCanisterActor": (()=>createAssetCanisterActor)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$actor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/actor.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$canisters$2f$asset_idl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/canisters/asset_idl.js [app-ssr] (ecmascript)");
;
;
function createAssetCanisterActor(config) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$actor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Actor"].createActor(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$canisters$2f$asset_idl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"], config);
} //# sourceMappingURL=asset.js.map
}}),
"[project]/node_modules/@dfinity/agent/lib/esm/fetch_candid.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "fetchCandid": (()=>fetchCandid)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/principal/lib/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$canisterStatus$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/canisterStatus/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/agent/http/index.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/agent/http/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$actor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/actor.js [app-ssr] (ecmascript)");
;
;
;
;
async function fetchCandid(canisterId, agent) {
    if (!agent) {
        // Create an anonymous `HttpAgent` (adapted from Candid UI)
        agent = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["HttpAgent"].create();
    }
    // Attempt to use canister metadata
    const status = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$canisterStatus$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["request"])({
        agent,
        canisterId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$principal$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Principal"].fromText(canisterId),
        paths: [
            'candid'
        ]
    });
    const candid = status.get('candid');
    if (candid) {
        return candid;
    }
    // Use `__get_candid_interface_tmp_hack` for canisters without Candid metadata
    const tmpHackInterface = ({ IDL })=>IDL.Service({
            __get_candid_interface_tmp_hack: IDL.Func([], [
                IDL.Text
            ], [
                'query'
            ])
        });
    const actor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$actor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Actor"].createActor(tmpHackInterface, {
        agent,
        canisterId
    });
    return await actor.__get_candid_interface_tmp_hack();
} //# sourceMappingURL=fetch_candid.js.map
}}),
"[project]/node_modules/@dfinity/agent/lib/esm/index.js [app-ssr] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@dfinity/agent/lib/esm/index.js [app-ssr] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$actor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/actor.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/agent/index.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$transforms$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/agent/http/transforms.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$agent$2f$http$2f$types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/agent/http/types.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$auth$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/auth.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$canisters$2f$asset$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/canisters/asset.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$certificate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/certificate.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$der$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/der.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$fetch_candid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/fetch_candid.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$observable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/observable.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$public_key$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/public_key.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$request_id$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/request_id.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$bls$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/utils/bls.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/utils/buffer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$utils$2f$random$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/utils/random.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$polling$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/polling/index.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$canisterStatus$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/canisterStatus/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$cbor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/cbor.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$dfinity$2f$agent$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@dfinity/agent/lib/esm/index.js [app-ssr] (ecmascript) <locals>");
}}),

};

//# sourceMappingURL=node_modules_%40dfinity_agent_lib_esm_10a42c03._.js.map