{
  "version": 3,
  "sources": ["../node_modules/nanoid/url-alphabet/index.js", "../node_modules/nanoid/index.browser.js", "../src/request-verifiable-presentation.ts"],
  "sourcesContent": ["export const urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\n", "import { urlAlphabet as scopedUrlAlphabet } from './url-alphabet/index.js'\nexport { urlAlphabet } from './url-alphabet/index.js'\nexport let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\nexport let customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let j = step\n      while (j--) {\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length === size) return id\n      }\n    }\n  }\n}\nexport let customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size, random)\nexport let nanoid = (size = 21) => {\n  let id = ''\n  let bytes = crypto.getRandomValues(new Uint8Array(size))\n  while (size--) {\n    id += scopedUrlAlphabet[bytes[size] & 63]\n  }\n  return id\n}\n", "/**\n * This module provides a function to request a verifiable presentation to an issuer through an Identity Provider.\n *\n * More info about the flow: https://github.com/dfinity/internet-identity/blob/main/docs/vc-spec.md\n *\n * There is only one function exposed: `requestVerifiablePresentation`.\n */\nimport type { Principal } from \"@dfinity/principal\";\nimport { nanoid } from \"nanoid\";\n\n/**\n * Helper types.\n */\ntype CredentialsArguments = Record<string, string | number>;\ntype CredentialType = string;\n/**\n * Types used to request the verifiable presentation.\n */\nexport type CredentialRequestSpec = {\n  credentialType: CredentialType;\n  arguments: CredentialsArguments;\n};\nexport type CredentialRequestData = {\n  credentialSpec: CredentialRequestSpec;\n  credentialSubject: Principal;\n};\nexport type IssuerData = {\n  origin: string;\n  canisterId: Principal;\n};\nconst VC_REQUEST_METHOD = \"request_credential\";\nconst VC_START_METHOD = \"vc-flow-ready\";\nconst JSON_RPC_VERSION = \"2.0\";\nexport type CredentialsRequest = {\n  id: FlowId;\n  jsonrpc: typeof JSON_RPC_VERSION;\n  method: typeof VC_REQUEST_METHOD;\n  params: {\n    issuer: {\n      origin: string;\n      canisterId: string;\n    };\n    credentialSpec: CredentialRequestSpec;\n    credentialSubject: string;\n    derivationOrigin?: string;\n  };\n};\n/**\n * Output types\n */\ntype VerifiablePresentation = string;\nexport type VerifiablePresentationResponse =\n  | { Ok: VerifiablePresentation }\n  | { Err: string };\nexport type OnSuccessCallback = (\n  verifiablePresentation: VerifiablePresentationResponse,\n) => void | Promise<void>;\nexport type OnErrorCallback = (err?: string) => void | Promise<void>;\n\n/**\n * Helper functions\n */\nconst idpWindows: Map<FlowId, Window | null> = new Map();\nconst createFlowId = (): FlowId => nanoid();\n\ntype FlowId = string;\n/**\n * State Machine of the flow:\n *    /<-------------------------------------------- Identity Provider closes window -----------------------------------------------------\\\n *   |<-- User closes window ----\\<--------------------------------\\<--------------------------------\\                                    |\n *   v                           |                                 |                                 |                                    |\n * (Off) -- open window --> (ongoing) -- receive ready msg --> (ongoing) -- send request msg --> (ongoing) -- receive response msg --> (finalized)\n *\n * We care about how the window is closed because in case of the user closing the window, we want to call `onError` with `ERROR_USER_INTERRUPT`.\n * But we can't listen to the event of the user closing the window. The only way we know about it is by checking at intervals whether the window is closed.\n */\ntype Status = \"initialized\" | \"started\" | \"ongoing\" | \"finalized\";\nconst currentFlows = new Map<FlowId, Status>();\n\nconst INTERRUPT_CHECK_INTERVAL = 500;\nexport const ERROR_USER_INTERRUPT = \"UserInterrupt\";\n\n// As defined in the spec: https://github.com/dfinity/internet-identity/blob/main/docs/vc-spec.md#2-request-a-vc\nconst createCredentialRequest = ({\n  issuerData,\n  derivationOrigin,\n  credentialData: { credentialSpec, credentialSubject },\n  nextFlowId,\n}: {\n  issuerData: IssuerData;\n  derivationOrigin: string | undefined;\n  credentialData: CredentialRequestData;\n  nextFlowId: FlowId;\n}): CredentialsRequest => {\n  return {\n    id: nextFlowId,\n    jsonrpc: JSON_RPC_VERSION,\n    method: VC_REQUEST_METHOD,\n    params: {\n      issuer: {\n        origin: issuerData.origin,\n        canisterId: issuerData.canisterId?.toText(),\n      },\n      credentialSpec,\n      credentialSubject: credentialSubject.toText(),\n      derivationOrigin: derivationOrigin,\n    },\n  };\n};\n\nconst getCredentialResponse = (\n  evnt: MessageEvent,\n): VerifiablePresentationResponse => {\n  if (evnt.data?.error !== undefined) {\n    return { Err: evnt.data.error };\n  }\n  const verifiablePresentation = evnt.data?.result?.verifiablePresentation;\n  if (verifiablePresentation === undefined) {\n    throw new Error(\n      `Key 'verifiablePresentation' not found in the message data: ${JSON.stringify(evnt.data)}`,\n    );\n  }\n  return { Ok: verifiablePresentation };\n};\n\nconst isJSONRPC = (evnt: MessageEvent): boolean => {\n  return evnt.data?.jsonrpc === JSON_RPC_VERSION;\n};\n\n// As defined in the spec: https://github.com/dfinity/internet-identity/blob/main/docs/vc-spec.md#1-load-ii-in-a-new-window\nconst isExpectedNotification = ({\n  evnt,\n  flowId,\n}: {\n  evnt: MessageEvent;\n  flowId: FlowId;\n}): boolean =>\n  evnt.data?.method === VC_START_METHOD &&\n  currentFlows.get(flowId) === \"initialized\";\n\n// As defined in the spec: https://github.com/dfinity/internet-identity/blob/main/docs/vc-spec.md#3-get-a-response\nconst isKnownFlowMessage = ({\n  evnt,\n  flowId,\n}: {\n  evnt: MessageEvent;\n  flowId: FlowId;\n}): boolean =>\n  currentFlows.get(evnt.data?.id) === \"ongoing\" && evnt.data?.id === flowId;\n\nexport type RequestVerifiablePresentationParams = {\n  onSuccess: OnSuccessCallback;\n  onError: (err?: string) => void | Promise<void>;\n  credentialData: CredentialRequestData;\n  issuerData: IssuerData;\n  windowOpenerFeatures?: string;\n  derivationOrigin?: string;\n  identityProvider: URL;\n};\n\n/**\n * Function to request a verifiable presentation to an issuer through an Identity Provider.\n *\n * Summary of the flow:\n * - Open a new window or tab with the Identity Provider.\n * - Wait for a window post message from the Identity Provider.\n * - Send a request to the Identity Provider through the window post message.\n * - Wait for the response from the Identity Provider.\n * - Call `onSuccess` callback when the flow was successful. Not necessarily that the credential was received.\n * - Call `onError` callback when the flow has some technical error or the user closes the window.\n *\n * @param {RequestVerifiablePresentationParams} params\n * @param {OnSuccessCallback} params.onSuccess - Callback function that is called when the flow with the Identity Provider is successful.\n * It receives either the verifiable presentation or an message that the credential was not received.\n * The message doesn't expose different errors to keep the privacy of the user.\n * @param {OnErrorCallback} params.onError - Callback function that is called when the flow has some technical error or the user closes the window.\n * @param {CredentialRequestData} params.credentialData - Data to request the verifiable credential.\n * @param {IssuerData} params.issuerData - Data of the issuer.\n * @param {string} params.windowOpenerFeatures - Features of the window that opens the Identity Provider.\n *   @example \"toolbar=0,location=0,menubar=0,width=500,height=500,left=100,top=100\"\n * @param {string} params.derivationOrigin - Indicates an origin that should be used for principal derivation.\n * It's the same value as the one used when logging in.\n * More info: https://internetcomputer.org/docs/current/references/ii-spec/#alternative-frontend-origins\n * @param {string} params.identityProvider - URL of the Identity Provider.\n * @returns {void}\n */\nexport const requestVerifiablePresentation = ({\n  onSuccess,\n  onError,\n  credentialData,\n  issuerData,\n  windowOpenerFeatures,\n  derivationOrigin,\n  identityProvider,\n}: RequestVerifiablePresentationParams): void => {\n  const handleFlowFactory = (currentFlowId: FlowId) => (evnt: MessageEvent) => {\n    // We convert the origin to URL type to avoid problems with trailing slashes\n    // when comparing it with the identityProvider.\n    let evntOriginUrl: URL | undefined;\n    try {\n      evntOriginUrl = new URL(evnt.origin);\n    } catch (err: unknown) {\n      console.warn(\n        `WARNING: expected origin to be URL, got '${evnt.origin} instead' (ignoring)`,\n      );\n      return;\n    }\n    // The handler is listening to all window messages.\n    // For example, a browser extension could send messages that we want to ignore.\n    if (evntOriginUrl?.origin !== identityProvider.origin) {\n      console.warn(\n        `WARNING: expected origin '${identityProvider}', got '${evntOriginUrl.origin}' (ignoring)`,\n      );\n      return;\n    }\n\n    // As defined in the spec: https://github.com/dfinity/internet-identity/blob/main/docs/vc-spec.md#interaction-model\n    if (!isJSONRPC(evnt)) {\n      console.warn(\n        `WARNING: expected JSON-RPC message, got '${JSON.stringify(evnt.data)}' (ignoring)`,\n      );\n      return;\n    }\n\n    if (isExpectedNotification({ evnt, flowId: currentFlowId })) {\n      currentFlows.set(currentFlowId, \"started\");\n      const request = createCredentialRequest({\n        derivationOrigin,\n        issuerData,\n        credentialData,\n        nextFlowId: currentFlowId,\n      });\n      evnt.source?.postMessage(request, { targetOrigin: evntOriginUrl.origin });\n      currentFlows.set(nextFlowId, \"ongoing\");\n      return;\n    }\n\n    if (isKnownFlowMessage({ evnt, flowId: currentFlowId })) {\n      try {\n        currentFlows.set(evnt.data.id, \"finalized\");\n        const credentialResponse = getCredentialResponse(evnt);\n        onSuccess(credentialResponse);\n      } catch (err) {\n        const message =\n          err instanceof Error ? err.message : JSON.stringify(err);\n        onError(`Error getting the verifiable credential: ${message}`);\n      } finally {\n        currentFlows.delete(currentFlowId);\n        idpWindows.get(currentFlowId)?.close();\n        idpWindows.delete(currentFlowId);\n        window.removeEventListener(\"message\", handleCurrentFlow);\n      }\n      return;\n    }\n\n    console.warn(\n      `WARNING: unexpected message: ${JSON.stringify(evnt.data)} (ignoring)`,\n    );\n  };\n  const nextFlowId = createFlowId();\n  currentFlows.set(nextFlowId, \"initialized\");\n  const handleCurrentFlow = handleFlowFactory(nextFlowId);\n  window.addEventListener(\"message\", handleCurrentFlow);\n  let url;\n  try {\n    url = new URL(identityProvider);\n  } catch (err) {\n    onError(\"The parameter `identityProvider` must be a valid URL.\");\n    return;\n  }\n  url.pathname = \"vc-flow/\";\n  // As defined in the spec: https://github.com/dfinity/internet-identity/blob/main/docs/vc-spec.md#1-load-ii-in-a-new-window\n  const idpWindow = window.open(url, \"idpWindow\", windowOpenerFeatures);\n  if (idpWindow !== null) {\n    idpWindows.set(nextFlowId, idpWindow);\n    // Check if the _idpWindow is closed by user.\n    const checkInterruption = (flowId: FlowId): void => {\n      // The _idpWindow is opened and not yet closed by the client\n      if (\n        idpWindow.closed &&\n        currentFlows.has(flowId) &&\n        currentFlows.get(flowId) !== \"finalized\"\n      ) {\n        currentFlows.delete(flowId);\n        idpWindows.delete(flowId);\n        window.removeEventListener(\"message\", handleCurrentFlow);\n        onError(ERROR_USER_INTERRUPT);\n      } else if (idpWindows.has(flowId)) {\n        setTimeout(() => checkInterruption(flowId), INTERRUPT_CHECK_INTERVAL);\n      }\n    };\n    checkInterruption(nextFlowId);\n  }\n};\n"],
  "mappings": "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",
  "names": ["urlAlphabet", "nanoid", "size", "id", "bytes", "urlAlphabet", "VC_REQUEST_METHOD", "VC_START_METHOD", "JSON_RPC_VERSION", "idpWindows", "createFlowId", "nanoid", "currentFlows", "INTERRUPT_CHECK_INTERVAL", "ERROR_USER_INTERRUPT", "createCredentialRequest", "issuerData", "derivationOrigin", "credentialSpec", "credentialSubject", "nextFlowId", "getCredentialResponse", "evnt", "verifiablePresentation", "isJSONRPC", "isExpectedNotification", "flowId", "isKnownFlowMessage", "requestVerifiablePresentation", "onSuccess", "onError", "credentialData", "windowOpenerFeatures", "identityProvider", "handleFlowFactory", "currentFlowId", "evntOriginUrl", "request", "credentialResponse", "err", "message", "handleCurrentFlow", "url", "idpWindow", "checkInterruption"]
}
